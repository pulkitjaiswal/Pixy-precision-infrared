; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--cpp --list --debug -c --asm --interleave -o.\spifi\i2c.o --asm_dir=.\ --list_dir=.\ --depend=.\spifi\i2c.d --cpu=Cortex-M4 --apcs=interwork -O0 -I. -I..\libpixy -I..\..\common -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.0\CMSIS\Include -DCORE_M4 -DIPC_MASTER -DPIXY --omf_browse=.\spifi\i2c.crf ..\libpixy\i2c.cpp]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _ZN3I2c12slaveHandlerEv PROC ; I2c::slaveHandler()
;;;28     
;;;29     void I2c::slaveHandler()
000000  b538              PUSH     {r3-r5,lr}
;;;30     {
000002  4604              MOV      r4,r0
;;;31     	uint8_t stat, c;
;;;32     
;;;33     	stat = m_i2c->STAT&I2C_STAT_CODE_BITMASK;
000004  6860              LDR      r0,[r4,#4]
000006  6840              LDR      r0,[r0,#4]
000008  f00005f8          AND      r5,r0,#0xf8
;;;34     	switch (stat)
00000c  2dc0              CMP      r5,#0xc0
00000e  d03a              BEQ      |L1.134|
000010  dc04              BGT      |L1.28|
000012  2da8              CMP      r5,#0xa8
000014  d00d              BEQ      |L1.50|
000016  2db8              CMP      r5,#0xb8
000018  d13c              BNE      |L1.148|
00001a  e00b              B        |L1.52|
                  |L1.28|
00001c  2dc8              CMP      r5,#0xc8
00001e  d031              BEQ      |L1.132|
000020  2df8              CMP      r5,#0xf8
000022  d137              BNE      |L1.148|
;;;35     	{
;;;36     	// No status information 
;;;37     	case I2C_I2STAT_NO_INF:
;;;38     		m_i2c->CONSET = I2C_I2CONSET_AA;
000024  2004              MOVS     r0,#4
000026  6861              LDR      r1,[r4,#4]
000028  6008              STR      r0,[r1,#0]
;;;39     		m_i2c->CONCLR = I2C_I2CONCLR_SIC;
00002a  2008              MOVS     r0,#8
00002c  6861              LDR      r1,[r4,#4]
00002e  6188              STR      r0,[r1,#0x18]
;;;40     		break;
000030  e034              B        |L1.156|
                  |L1.50|
;;;41     
;;;42     	// Writing phase
;;;43     	// Own SLA+R has been received, ACK has been returned 
;;;44     	case I2C_I2STAT_S_TX_SLAR_ACK:
;;;45     	// Data has been transmitted, ACK has been received */
;;;46     	case I2C_I2STAT_S_TX_DAT_ACK:
000032  bf00              NOP      
                  |L1.52|
;;;47     		if (m_tq.read(&c))
000034  bf00              NOP      
000036  6ae0              LDR      r0,[r4,#0x2c]
000038  b950              CBNZ     r0,|L1.80|
00003a  6b22              LDR      r2,[r4,#0x30]
00003c  e9d41008          LDRD     r1,r0,[r4,#0x20]
000040  4790              BLX      r2
000042  62e0              STR      r0,[r4,#0x2c]
000044  6ae0              LDR      r0,[r4,#0x2c]
000046  b908              CBNZ     r0,|L1.76|
000048  2000              MOVS     r0,#0
00004a  e00b              B        |L1.100|
                  |L1.76|
00004c  2000              MOVS     r0,#0
00004e  62a0              STR      r0,[r4,#0x28]
                  |L1.80|
000050  6aa1              LDR      r1,[r4,#0x28]
000052  1c48              ADDS     r0,r1,#1
000054  62a0              STR      r0,[r4,#0x28]
000056  6a60              LDR      r0,[r4,#0x24]
000058  5c40              LDRB     r0,[r0,r1]
00005a  9000              STR      r0,[sp,#0]
00005c  6ae0              LDR      r0,[r4,#0x2c]
00005e  1e40              SUBS     r0,r0,#1
000060  62e0              STR      r0,[r4,#0x2c]
000062  2001              MOVS     r0,#1
                  |L1.100|
000064  b120              CBZ      r0,|L1.112|
;;;48     			m_i2c->DAT = c;
000066  f89d0000          LDRB     r0,[sp,#0]
00006a  6861              LDR      r1,[r4,#4]
00006c  6088              STR      r0,[r1,#8]
00006e  e002              B        |L1.118|
                  |L1.112|
;;;49     		else 
;;;50     			m_i2c->DAT = 0;
000070  2000              MOVS     r0,#0
000072  6861              LDR      r1,[r4,#4]
000074  6088              STR      r0,[r1,#8]
                  |L1.118|
;;;51     		m_i2c->CONSET = I2C_I2CONSET_AA;
000076  2004              MOVS     r0,#4
000078  6861              LDR      r1,[r4,#4]
00007a  6008              STR      r0,[r1,#0]
;;;52     		m_i2c->CONCLR = I2C_I2CONCLR_SIC;
00007c  2008              MOVS     r0,#8
00007e  6861              LDR      r1,[r4,#4]
000080  6188              STR      r0,[r1,#0x18]
;;;53     		break;
000082  e00b              B        |L1.156|
                  |L1.132|
;;;54     
;;;55     	case I2C_I2STAT_S_TX_LAST_DAT_ACK:
;;;56     	case I2C_I2STAT_S_TX_DAT_NACK:
000084  bf00              NOP      
                  |L1.134|
;;;57     		m_i2c->CONSET = I2C_I2CONSET_AA;
000086  2004              MOVS     r0,#4
000088  6861              LDR      r1,[r4,#4]
00008a  6008              STR      r0,[r1,#0]
;;;58     		m_i2c->CONCLR = I2C_I2CONCLR_SIC;
00008c  2008              MOVS     r0,#8
00008e  6861              LDR      r1,[r4,#4]
000090  6188              STR      r0,[r1,#0x18]
;;;59     		break;
000092  e003              B        |L1.156|
                  |L1.148|
;;;60     
;;;61     	// Other status must be captured
;;;62     	default:
;;;63     		m_i2c->CONCLR = I2C_I2CONCLR_AAC | I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC;
000094  202c              MOVS     r0,#0x2c
000096  6861              LDR      r1,[r4,#4]
000098  6188              STR      r0,[r1,#0x18]
;;;64     		break;
00009a  bf00              NOP      
                  |L1.156|
00009c  bf00              NOP                            ;40
;;;65     	}
;;;66     }
00009e  bd38              POP      {r3-r5,pc}
;;;67     
                          ENDP

                  I2C0_IRQHandler PROC
;;;23     
;;;24     void I2C0_IRQHandler(void)
0000a0  b510              PUSH     {r4,lr}
;;;25     {
;;;26     	g_i2c0->slaveHandler();
0000a2  485f              LDR      r0,|L1.544|
0000a4  6800              LDR      r0,[r0,#0]  ; g_i2c0
0000a6  f7fffffe          BL       _ZN3I2c12slaveHandlerEv ; I2c::slaveHandler()
;;;27     }
0000aa  bd10              POP      {r4,pc}
;;;28     
                          ENDP

                  _ZN3I2c12setSlaveAddrEh PROC ; I2c::setSlaveAddr(unsigned char)
;;;122    
;;;123    int I2c::setSlaveAddr(uint8_t addr)
0000ac  b538              PUSH     {r3-r5,lr}
;;;124    {
0000ae  4604              MOV      r4,r0
0000b0  460d              MOV      r5,r1
;;;125    	I2C_OWNSLAVEADDR_CFG_Type slaveAddr;
;;;126    	slaveAddr.SlaveAddr_7bit = addr;
0000b2  f88d5001          STRB     r5,[sp,#1]
;;;127    	slaveAddr.SlaveAddrMaskValue = 0;
0000b6  2000              MOVS     r0,#0
0000b8  f88d0003          STRB     r0,[sp,#3]
;;;128    	slaveAddr.SlaveAddrChannel = 0;
0000bc  f88d0000          STRB     r0,[sp,#0]
;;;129    	I2C_SetOwnSlaveAddr(m_i2c, &slaveAddr);
0000c0  4669              MOV      r1,sp
0000c2  6860              LDR      r0,[r4,#4]
0000c4  f7fffffe          BL       I2C_SetOwnSlaveAddr
;;;130    
;;;131    	return 0;
0000c8  2000              MOVS     r0,#0
;;;132    }
0000ca  bd38              POP      {r3-r5,pc}
;;;133    
                          ENDP

                  _ZN3I2cC2EP13LPC_I2Cn_TypehPFjPhjE                  ; Alternate entry point ; I2c::I2c__sub_object(LPC_I2Cn_Type*, unsigned char, unsigned(*)(unsigned char*, unsigned))
                  _ZN3I2cC1EP13LPC_I2Cn_TypehPFjPhjE PROC ; I2c::I2c(LPC_I2Cn_Type*, unsigned char, unsigned(*)(unsigned char*, unsigned))
;;;112    
;;;113    I2c::I2c(LPC_I2Cn_Type *i2c, uint8_t addr, SerialCallback callback) : m_rq(I2C_RECEIVE_BUF_SIZE), m_tq(I2C_TRANSMIT_BUF_SIZE, callback)
;;;114    {
;;;115    	m_i2c = i2c;
;;;116    	 
;;;117    	I2C_Init(m_i2c, 100000);
;;;118       	setSlaveAddr(addr);
;;;119    
;;;120    	NVIC_SetPriority(SSP1_IRQn, 0);	// high priority interrupt
;;;121    }
;;;122    
0000cc  e92d47f0          PUSH     {r4-r10,lr}
0000d0  4605              MOV      r5,r0
0000d2  460f              MOV      r7,r1
0000d4  4690              MOV      r8,r2
0000d6  461e              MOV      r6,r3
0000d8  4952              LDR      r1,|L1.548|
0000da  4853              LDR      r0,|L1.552|
0000dc  6028              STR      r0,[r5,#0]
0000de  f1050408          ADD      r4,r5,#8
0000e2  f04f0920          MOV      r9,#0x20
0000e6  f8c49000          STR      r9,[r4,#0]
0000ea  6820              LDR      r0,[r4,#0]
0000ec  f7fffffe          BL       _Znaj ; operator new[] (unsigned)
0000f0  6060              STR      r0,[r4,#4]
0000f2  2000              MOVS     r0,#0
0000f4  60a0              STR      r0,[r4,#8]
0000f6  60e0              STR      r0,[r4,#0xc]
0000f8  6120              STR      r0,[r4,#0x10]
0000fa  6160              STR      r0,[r4,#0x14]
0000fc  bf00              NOP      
0000fe  f1a40508          SUB      r5,r4,#8
000102  f1050420          ADD      r4,r5,#0x20
000106  f8c49000          STR      r9,[r4,#0]
00010a  6820              LDR      r0,[r4,#0]
00010c  f7fffffe          BL       _Znaj ; operator new[] (unsigned)
000110  6060              STR      r0,[r4,#4]
000112  2000              MOVS     r0,#0
000114  60a0              STR      r0,[r4,#8]
000116  60e0              STR      r0,[r4,#0xc]
000118  6126              STR      r6,[r4,#0x10]
00011a  bf00              NOP      
00011c  f1a40520          SUB      r5,r4,#0x20
000120  606f              STR      r7,[r5,#4]
000122  4942              LDR      r1,|L1.556|
000124  6868              LDR      r0,[r5,#4]
000126  f7fffffe          BL       I2C_Init
00012a  4641              MOV      r1,r8
00012c  4628              MOV      r0,r5
00012e  f7fffffe          BL       _ZN3I2c12setSlaveAddrEh ; I2c::setSlaveAddr(unsigned char)
000132  2017              MOVS     r0,#0x17
000134  2100              MOVS     r1,#0
000136  2800              CMP      r0,#0
000138  da07              BGE      |L1.330|
00013a  070a              LSLS     r2,r1,#28
00013c  0e14              LSRS     r4,r2,#24
00013e  4a3c              LDR      r2,|L1.560|
000140  f000030f          AND      r3,r0,#0xf
000144  1f1b              SUBS     r3,r3,#4
000146  54d4              STRB     r4,[r2,r3]
000148  e003              B        |L1.338|
                  |L1.330|
00014a  070a              LSLS     r2,r1,#28
00014c  0e13              LSRS     r3,r2,#24
00014e  4a39              LDR      r2,|L1.564|
000150  5413              STRB     r3,[r2,r0]
                  |L1.338|
000152  bf00              NOP      
000154  4628              MOV      r0,r5
000156  e8bd87f0          POP      {r4-r10,pc}
                          ENDP

                  _Z8i2c_initPFjPhjE PROC ; i2c_init(unsigned(*)(unsigned char*, unsigned))
;;;133    
;;;134    void i2c_init(SerialCallback callback)
00015a  b570              PUSH     {r4-r6,lr}
;;;135    {
00015c  4604              MOV      r4,r0
;;;136    	g_i2c0 = new I2c(LPC_I2C0, I2C_DEFAULT_SLAVE_ADDR, callback);
00015e  2034              MOVS     r0,#0x34
000160  f7fffffe          BL       _Znwj ; operator new(unsigned)
000164  4605              MOV      r5,r0
000166  4623              MOV      r3,r4
000168  2254              MOVS     r2,#0x54
00016a  4933              LDR      r1,|L1.568|
00016c  f7fffffe          BL       _ZN3I2cC1EP13LPC_I2Cn_TypehPFjPhjE ; I2c::I2c(LPC_I2Cn_Type*, unsigned char, unsigned(*)(unsigned char*, unsigned))
000170  4605              MOV      r5,r0
000172  482b              LDR      r0,|L1.544|
000174  6005              STR      r5,[r0,#0]  ; g_i2c0
;;;137    }
000176  bd70              POP      {r4-r6,pc}
                          ENDP

                  _ZN3I2c10startSlaveEv PROC ; I2c::startSlave()
;;;106    
;;;107    void I2c::startSlave()
000178  2138              MOVS     r1,#0x38
;;;108    {
;;;109    	m_i2c->CONCLR = I2C_I2CONCLR_SIC | I2C_I2CONCLR_STOC | I2C_I2CONCLR_STAC;
00017a  6842              LDR      r2,[r0,#4]
00017c  6191              STR      r1,[r2,#0x18]
;;;110    	m_i2c->CONSET = I2C_I2CONSET_AA | I2C_I2CONSET_I2EN;
00017e  2144              MOVS     r1,#0x44
000180  6842              LDR      r2,[r0,#4]
000182  6011              STR      r1,[r2,#0]
;;;111    }
000184  4770              BX       lr
;;;112    
                          ENDP

                  _ZN3I2c4openEv PROC ; I2c::open()
;;;67     
;;;68     int I2c::open()
000186  b510              PUSH     {r4,lr}
;;;69     {
000188  4604              MOV      r4,r0
;;;70     	// make all pins on the I/O connector high impedance so we can just daisy chain the whole connector together
;;;71     	scu_pinmux(0x1, 3, (MD_PLN | MD_EZI | MD_ZI | MD_EHS), FUNC0); 
00018a  2300              MOVS     r3,#0
00018c  22f0              MOVS     r2,#0xf0
00018e  2103              MOVS     r1,#3
000190  2001              MOVS     r0,#1
000192  f7fffffe          BL       scu_pinmux
;;;72     	scu_pinmux(0x2, 1, (MD_PLN | MD_EZI | MD_ZI | MD_EHS), FUNC4); 	         
000196  2304              MOVS     r3,#4
000198  22f0              MOVS     r2,#0xf0
00019a  2101              MOVS     r1,#1
00019c  2002              MOVS     r0,#2
00019e  f7fffffe          BL       scu_pinmux
;;;73     	scu_pinmux(0x2, 1, (MD_PLN | MD_EZI | MD_ZI | MD_EHS), FUNC4); 	         
0001a2  2304              MOVS     r3,#4
0001a4  22f0              MOVS     r2,#0xf0
0001a6  2101              MOVS     r1,#1
0001a8  2002              MOVS     r0,#2
0001aa  f7fffffe          BL       scu_pinmux
;;;74     	scu_pinmux(0x1, 4, (MD_PLN | MD_EZI | MD_ZI | MD_EHS), FUNC0); 	         
0001ae  2300              MOVS     r3,#0
0001b0  22f0              MOVS     r2,#0xf0
0001b2  2104              MOVS     r1,#4
0001b4  2001              MOVS     r0,#1
0001b6  f7fffffe          BL       scu_pinmux
;;;75     	scu_pinmux(0x2, 0, (MD_PLN | MD_EZI | MD_ZI | MD_EHS), FUNC4); 	         
0001ba  2304              MOVS     r3,#4
0001bc  22f0              MOVS     r2,#0xf0
0001be  2100              MOVS     r1,#0
0001c0  2002              MOVS     r0,#2
0001c2  f7fffffe          BL       scu_pinmux
;;;76     	// turn off driver for SS signal so we can wire-or them together
;;;77     	LPC_SGPIO->GPIO_OENREG = 0;
0001c6  2000              MOVS     r0,#0
0001c8  491c              LDR      r1,|L1.572|
0001ca  6008              STR      r0,[r1,#0]
;;;78     
;;;79     	NVIC_EnableIRQ(I2C0_IRQn);
0001cc  2012              MOVS     r0,#0x12
0001ce  2101              MOVS     r1,#1
0001d0  4081              LSLS     r1,r1,r0
0001d2  0942              LSRS     r2,r0,#5
0001d4  0092              LSLS     r2,r2,#2
0001d6  f10222e0          ADD      r2,r2,#0xe000e000
0001da  f8c21100          STR      r1,[r2,#0x100]
0001de  bf00              NOP      
;;;80     	startSlave(); 
0001e0  4620              MOV      r0,r4
0001e2  f7fffffe          BL       _ZN3I2c10startSlaveEv ; I2c::startSlave()
;;;81     
;;;82     	return 0;
0001e6  2000              MOVS     r0,#0
;;;83     }
0001e8  bd10              POP      {r4,pc}
;;;84     
                          ENDP

                  _ZN3I2c5closeEv PROC ; I2c::close()
;;;85     int I2c::close()
0001ea  b510              PUSH     {r4,lr}
;;;86     {
0001ec  4601              MOV      r1,r0
;;;87     	NVIC_DisableIRQ(I2C0_IRQn);
0001ee  2012              MOVS     r0,#0x12
0001f0  2201              MOVS     r2,#1
0001f2  4082              LSLS     r2,r2,r0
0001f4  4b12              LDR      r3,|L1.576|
0001f6  0944              LSRS     r4,r0,#5
0001f8  f8432024          STR      r2,[r3,r4,LSL #2]
0001fc  bf00              NOP      
;;;88     	return 0;
0001fe  2000              MOVS     r0,#0
;;;89     }
000200  bd10              POP      {r4,pc}
;;;90     
                          ENDP

                  _ZN3I2c7receiveEPhj PROC ; I2c::receive(unsigned char*, unsigned)
;;;91     int I2c::receive(uint8_t *buf, uint32_t len)
000202  4603              MOV      r3,r0
;;;92     {
;;;93     	return 0;
000204  2000              MOVS     r0,#0
;;;94     }
000206  4770              BX       lr
;;;95     
                          ENDP

                  _ZN3I2c6updateEv PROC ; I2c::update()
;;;96     int I2c::update()
000208  b500              PUSH     {lr}
;;;97     {
00020a  4603              MOV      r3,r0
;;;98     	// try to recover from out of sync condition between slave (us) and master
;;;99     	// happens when cable is unplugged/plugged
;;;100    	if ((m_i2c->CONSET&I2C_I2CONSET_AA)==0)
00020c  6858              LDR      r0,[r3,#4]
00020e  6800              LDR      r0,[r0,#0]
000210  f0000004          AND      r0,r0,#4
000214  b910              CBNZ     r0,|L1.540|
;;;101    		startSlave();
000216  4618              MOV      r0,r3
000218  f7fffffe          BL       _ZN3I2c10startSlaveEv ; I2c::startSlave()
                  |L1.540|
;;;102    
;;;103    	return 0;
00021c  2000              MOVS     r0,#0
;;;104    }
00021e  bd00              POP      {pc}
;;;105    
                          ENDP

                  |L1.544|
                          DCD      g_i2c0
                  |L1.548|
                          DCD      _ZTV7Iserial+0x8 ; vtable for Iserial
                  |L1.552|
                          DCD      _ZTV3I2c+0x8 ; vtable for I2c
                  |L1.556|
                          DCD      0x000186a0
                  |L1.560|
                          DCD      0xe000ed18
                  |L1.564|
                          DCD      0xe000e400
                  |L1.568|
                          DCD      0x400a1000
                  |L1.572|
                          DCD      0x40101218
                  |L1.576|
                          DCD      0xe000e180

                          AREA ||.ARM.exidx||, LINKORDER=||.text||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||.text||
                          DCD      0x00000001

                          AREA ||.data||, DATA, ALIGN=2

                  g_i2c0
                          DCD      0x00000000

                          AREA ||.constdata__ZTV3I2c||, COMGROUP=_ZTV3I2c, DATA, READONLY, ALIGN=2

                  _ZTV3I2c ; vtable for I2c
                          DCD      0x00000000
                          DCD      _ZTI3I2c ; typeinfo for I2c
                          DCD      _ZN3I2c4openEv ; I2c::open()
                          DCD      _ZN3I2c5closeEv ; I2c::close()
                          DCD      _ZN3I2c7receiveEPhj ; I2c::receive(unsigned char*, unsigned)
                          DCD      _ZN7Iserial10receiveLenEv ; Iserial::receiveLen()
                          DCD      _ZN3I2c6updateEv ; I2c::update()

                          AREA ||i._ZN7Iserial10receiveLenEv||, COMGROUP=_ZN7Iserial10receiveLenEv, CODE, READONLY, ALIGN=1

                  _ZN7Iserial10receiveLenEv PROC ; Iserial::receiveLen()
;;;143    	}
;;;144    	virtual int receiveLen()
000000  4601              MOV      r1,r0
;;;145    	{
;;;146    		return 0;
000002  2000              MOVS     r0,#0
;;;147    	}
000004  4770              BX       lr
;;;148    	virtual int update()
                          ENDP


                          AREA ||area_number.21||, COMGROUP=_ZN7Iserial10receiveLenEv, LINKORDER=||i._ZN7Iserial10receiveLenEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.21||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN7Iserial10receiveLenEv||
                          DCD      0x00000001

                          AREA ||.constdata__ZTV7Iserial||, COMGROUP=_ZTV7Iserial, DATA, READONLY, ALIGN=2

                  _ZTV7Iserial ; vtable for Iserial
                          DCD      0x00000000
                          DCD      _ZTI7Iserial ; typeinfo for Iserial
                          DCD      _ZN7Iserial4openEv ; Iserial::open()
                          DCD      _ZN7Iserial5closeEv ; Iserial::close()
                          DCD      _ZN7Iserial7receiveEPhj ; Iserial::receive(unsigned char*, unsigned)
                          DCD      _ZN7Iserial10receiveLenEv ; Iserial::receiveLen()
                          DCD      _ZN7Iserial6updateEv ; Iserial::update()

                          AREA ||.constdata__ZTI3I2c||, COMGROUP=_ZTI3I2c, DATA, READONLY, ALIGN=2

                  _ZTI3I2c ; typeinfo for I2c
                          DCD      _ZTVN10__cxxabiv120__si_class_type_infoE+0x8 ; vtable for __cxxabiv1::__si_class_type_info
                          DCD      _ZTS3I2c ; typeinfo name for I2c
                          DCD      _ZTI7Iserial ; typeinfo for Iserial

                          AREA ||.constdata__ZTI7Iserial||, COMGROUP=_ZTI7Iserial, DATA, READONLY, ALIGN=2

                  _ZTI7Iserial ; typeinfo for Iserial
                          DCD      _ZTVN10__cxxabiv117__class_type_infoE+0x8 ; vtable for __cxxabiv1::__class_type_info
                          DCD      _ZTS7Iserial ; typeinfo name for Iserial

                          AREA ||.constdata__ZTS3I2c||, COMGROUP=_ZTS3I2c, DATA, READONLY, ALIGN=0

                  _ZTS3I2c ; typeinfo name for I2c
000000  33493263          DCB      0x33,0x49,0x32,0x63
000004  00                DCB      0x00

                          AREA ||.constdata__ZTS7Iserial||, COMGROUP=_ZTS7Iserial, DATA, READONLY, ALIGN=0

                  _ZTS7Iserial ; typeinfo name for Iserial
000000  37497365          DCB      0x37,0x49,0x73,0x65
000004  7269616c          DCB      0x72,0x69,0x61,0x6c
000008  00                DCB      0x00

                          AREA ||i._ZN7Iserial4openEv||, COMGROUP=_ZN7Iserial4openEv, CODE, READONLY, ALIGN=1

                  _ZN7Iserial4openEv PROC ; Iserial::open()
;;;131    public:
;;;132    	virtual int open()
000000  4601              MOV      r1,r0
;;;133    	{
;;;134    		return 0;
000002  2000              MOVS     r0,#0
;;;135    	}
000004  4770              BX       lr
;;;136    	virtual int close()
                          ENDP


                          AREA ||area_number.39||, COMGROUP=_ZN7Iserial4openEv, LINKORDER=||i._ZN7Iserial4openEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.39||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN7Iserial4openEv||
                          DCD      0x00000001

                          AREA ||i._ZN7Iserial5closeEv||, COMGROUP=_ZN7Iserial5closeEv, CODE, READONLY, ALIGN=1

                  _ZN7Iserial5closeEv PROC ; Iserial::close()
;;;135    	}
;;;136    	virtual int close()
000000  4601              MOV      r1,r0
;;;137    	{
;;;138    		return 0;
000002  2000              MOVS     r0,#0
;;;139    	}
000004  4770              BX       lr
;;;140    	virtual int receive(uint8_t *buf, uint32_t len)
                          ENDP


                          AREA ||area_number.46||, COMGROUP=_ZN7Iserial5closeEv, LINKORDER=||i._ZN7Iserial5closeEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.46||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN7Iserial5closeEv||
                          DCD      0x00000001

                          AREA ||i._ZN7Iserial7receiveEPhj||, COMGROUP=_ZN7Iserial7receiveEPhj, CODE, READONLY, ALIGN=1

                  _ZN7Iserial7receiveEPhj PROC ; Iserial::receive(unsigned char*, unsigned)
;;;139    	}
;;;140    	virtual int receive(uint8_t *buf, uint32_t len)
000000  4603              MOV      r3,r0
;;;141    	{
;;;142    		return 0;
000002  2000              MOVS     r0,#0
;;;143    	}
000004  4770              BX       lr
;;;144    	virtual int receiveLen()
                          ENDP


                          AREA ||area_number.53||, COMGROUP=_ZN7Iserial7receiveEPhj, LINKORDER=||i._ZN7Iserial7receiveEPhj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.53||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN7Iserial7receiveEPhj||
                          DCD      0x00000001

                          AREA ||i._ZN7Iserial6updateEv||, COMGROUP=_ZN7Iserial6updateEv, CODE, READONLY, ALIGN=1

                  _ZN7Iserial6updateEv PROC ; Iserial::update()
;;;147    	}
;;;148    	virtual int update()
000000  4601              MOV      r1,r0
;;;149    	{
;;;150    		return 0;
000002  2000              MOVS     r0,#0
;;;151    	}
000004  4770              BX       lr
;;;152    };
                          ENDP


                          AREA ||area_number.60||, COMGROUP=_ZN7Iserial6updateEv, LINKORDER=||i._ZN7Iserial6updateEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.60||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN7Iserial6updateEv||
                          DCD      0x00000001

;*** Start embedded assembler ***

#line 1 "..\\libpixy\\i2c.cpp"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___7_i2c_cpp_b80b4882___Z7__REV16j|
#line 130 "..\\libpixy\\core_cmInstr.h"
|__asm___7_i2c_cpp_b80b4882___Z7__REV16j| PROC
#line 131

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___7_i2c_cpp_b80b4882___Z7__REVSHi|
#line 144
|__asm___7_i2c_cpp_b80b4882___Z7__REVSHi| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
