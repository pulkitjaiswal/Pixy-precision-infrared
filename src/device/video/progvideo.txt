; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--cpp --list --debug -c --asm --interleave -o.\spifi\progvideo.o --asm_dir=.\ --list_dir=.\ --depend=.\spifi\progvideo.d --cpu=Cortex-M4 --apcs=interwork -O0 -I. -I..\libpixy -I..\..\common -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.0\CMSIS\Include -DCORE_M4 -DIPC_MASTER -DPIXY --omf_browse=.\spifi\progvideo.crf progvideo.cpp]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  _Z15loadColorModelsPh PROC ; loadColorModels(unsigned char*)
;;;34     
;;;35     void loadColorModels(uint8_t *cmodels)
000000  b530              PUSH     {r4,r5,lr}
;;;36     {
000002  b08b              SUB      sp,sp,#0x2c
000004  4605              MOV      r5,r0
;;;37     	int i;
;;;38     	uint32_t len;
;;;39     	char id[32];
;;;40     	ColorModel *cmodel;
;;;41     
;;;42     	for (i=1; i<=NUM_MODELS; i++, cmodels+=sizeof(ColorModel))
000006  2401              MOVS     r4,#1
000008  e011              B        |L1.46|
                  |L1.10|
;;;43     	{
;;;44     		sprintf(id, "signature%d", i);
00000a  4622              MOV      r2,r4
00000c  a147              ADR      r1,|L1.300|
00000e  a802              ADD      r0,sp,#8
000010  f7fffffe          BL       __2sprintf
;;;45     		// get signature and add to color lut
;;;46     		prm_get(id, &len, &cmodel, END);
000014  2300              MOVS     r3,#0
000016  aa01              ADD      r2,sp,#4
000018  a90a              ADD      r1,sp,#0x28
00001a  a802              ADD      r0,sp,#8
00001c  f7fffffe          BL       _Z7prm_getPKcz ; prm_get(const char*, ...)
;;;47     		memcpy(cmodels, cmodel, sizeof(ColorModel));
000020  2224              MOVS     r2,#0x24
000022  4628              MOV      r0,r5
000024  9901              LDR      r1,[sp,#4]
000026  f7fffffe          BL       __aeabi_memcpy
00002a  1c64              ADDS     r4,r4,#1              ;42
00002c  3524              ADDS     r5,r5,#0x24           ;42
                  |L1.46|
00002e  2c07              CMP      r4,#7                 ;42
000030  ddeb              BLE      |L1.10|
;;;48     	}
;;;49     }
000032  b00b              ADD      sp,sp,#0x2c
000034  bd30              POP      {r4,r5,pc}
;;;50     
                          ENDP

                  _Z10videoSetupv PROC ; videoSetup()
;;;51     int videoSetup()
000036  2001              MOVS     r0,#1
;;;52     {
;;;53     	g_loadModels = true;
000038  493f              LDR      r1,|L1.312|
00003a  7008              STRB     r0,[r1,#0]
;;;54     
;;;55     	return 0;
00003c  2000              MOVS     r0,#0
;;;56     }
00003e  4770              BX       lr
;;;57     
                          ENDP

                  _Z8sendCMV1h PROC ; sendCMV1(unsigned char)
;;;58     void sendCMV1(uint8_t renderFlags=RENDER_FLAG_FLUSH)
000040  b5f0              PUSH     {r4-r7,lr}
;;;59     {
000042  b0cd              SUB      sp,sp,#0x134
000044  4606              MOV      r6,r0
;;;60     	int32_t len;
;;;61     	uint8_t *frame = (uint8_t *)SRAM1_LOC;
000046  4f3d              LDR      r7,|L1.316|
;;;62     	uint8_t cmodels[sizeof(ColorModel)*NUM_MODELS];
;;;63     	static int prevRes = CRP_RES_OK;
;;;64     	int res;
;;;65     
;;;66     	if (g_loadModels)
000048  483b              LDR      r0,|L1.312|
00004a  7800              LDRB     r0,[r0,#0]  ; g_loadModels
00004c  b110              CBZ      r0,|L1.84|
;;;67     		loadColorModels(cmodels);
00004e  a80e              ADD      r0,sp,#0x38
000050  f7fffffe          BL       _Z15loadColorModelsPh ; loadColorModels(unsigned char*)
                  |L1.84|
;;;68     
;;;69     	// fill buffer contents manually for return data 
;;;70     	len = Chirp::serialize(g_chirpUsb, frame, SRAM1_SIZE, HTYPE(FOURCC('C','M','V','1')), HINT8(renderFlags), FLTS32(g_loadModels ? sizeof(ColorModel)*NUM_MODELS/sizeof(float) : 0, cmodels), UINT16(CAM_RES2_WIDTH), UINT16(CAM_RES2_HEIGHT), UINTS8_NO_COPY(CAM_RES2_WIDTH*CAM_RES2_HEIGHT), END);
000054  2000              MOVS     r0,#0
000056  f44f417a          MOV      r1,#0xfa00
00005a  22b1              MOVS     r2,#0xb1
00005c  23c8              MOVS     r3,#0xc8
00005e  e9cd3209          STRD     r3,r2,[sp,#0x24]
000062  e9cd100b          STRD     r1,r0,[sp,#0x2c]
000066  2002              MOVS     r0,#2
000068  f44f71a0          MOV      r1,#0x140
00006c  ab0e              ADD      r3,sp,#0x38
00006e  e9cd3005          STRD     r3,r0,[sp,#0x14]
000072  e9cd1007          STRD     r1,r0,[sp,#0x1c]
000076  4830              LDR      r0,|L1.312|
000078  7800              LDRB     r0,[r0,#0]  ; g_loadModels
00007a  b108              CBZ      r0,|L1.128|
00007c  203f              MOVS     r0,#0x3f
00007e  e000              B        |L1.130|
                  |L1.128|
000080  2000              MOVS     r0,#0
                  |L1.130|
000082  2194              MOVS     r1,#0x94
000084  2241              MOVS     r2,#0x41
000086  e9cd2601          STRD     r2,r6,[sp,#4]
00008a  e9cd1003          STRD     r1,r0,[sp,#0xc]
00008e  482c              LDR      r0,|L1.320|
000090  2364              MOVS     r3,#0x64
000092  f44f3290          MOV      r2,#0x12000
000096  4639              MOV      r1,r7
000098  9000              STR      r0,[sp,#0]
00009a  482a              LDR      r0,|L1.324|
00009c  6800              LDR      r0,[r0,#0]  ; g_chirpUsb
00009e  f7fffffe          BL       _ZN5Chirp9serializeEPS_Phjz ; Chirp::serialize(Chirp*, unsigned char*, unsigned, ...)
0000a2  4604              MOV      r4,r0
;;;71     	// write frame after chirp args
;;;72     	cam_getFrame(frame+len, SRAM1_SIZE-len, CAM_GRAB_M1R2, 0, 0, CAM_RES2_WIDTH, CAM_RES2_HEIGHT);
0000a4  20c8              MOVS     r0,#0xc8
0000a6  f44f71a0          MOV      r1,#0x140
0000aa  2200              MOVS     r2,#0
0000ac  e9cd2100          STRD     r2,r1,[sp,#0]
0000b0  9002              STR      r0,[sp,#8]
0000b2  f5c43190          RSB      r1,r4,#0x12000
0000b6  1938              ADDS     r0,r7,r4
0000b8  4613              MOV      r3,r2
0000ba  2221              MOVS     r2,#0x21
0000bc  f7fffffe          BL       _Z12cam_getFramePhjhtttt ; cam_getFrame(unsigned char*, unsigned, unsigned char, unsigned short, unsigned short, unsigned short, unsigned short)
;;;73     
;;;74     	// tell chirp to use this buffer
;;;75     	res = g_chirpUsb->useBuffer(frame, len+CAM_RES2_WIDTH*CAM_RES2_HEIGHT); 
0000c0  f504427a          ADD      r2,r4,#0xfa00
0000c4  4639              MOV      r1,r7
0000c6  481f              LDR      r0,|L1.324|
0000c8  6800              LDR      r0,[r0,#0]  ; g_chirpUsb
0000ca  f7fffffe          BL       _ZN5Chirp9useBufferEPhj ; Chirp::useBuffer(unsigned char*, unsigned)
0000ce  4605              MOV      r5,r0
;;;76     
;;;77     	g_loadModels = false;
0000d0  2000              MOVS     r0,#0
0000d2  4919              LDR      r1,|L1.312|
0000d4  7008              STRB     r0,[r1,#0]
;;;78     
;;;79     	if (res==CRP_RES_OK && prevRes!=CRP_RES_OK) // force a reload
0000d6  b925              CBNZ     r5,|L1.226|
0000d8  481b              LDR      r0,|L1.328|
0000da  6800              LDR      r0,[r0,#0]  ; prevRes
0000dc  b108              CBZ      r0,|L1.226|
;;;80     		g_loadModels = true;
0000de  2001              MOVS     r0,#1
0000e0  7008              STRB     r0,[r1,#0]
                  |L1.226|
;;;81     	prevRes = res;
0000e2  4819              LDR      r0,|L1.328|
0000e4  6005              STR      r5,[r0,#0]  ; prevRes
;;;82     }
0000e6  b04d              ADD      sp,sp,#0x134
0000e8  bdf0              POP      {r4-r7,pc}
;;;83     
                          ENDP

                  _Z9videoLoopv PROC ; videoLoop()
;;;84     int videoLoop()
0000ea  b500              PUSH     {lr}
;;;85     {
0000ec  b087              SUB      sp,sp,#0x1c
;;;86     	if (g_execArg==0)
0000ee  4817              LDR      r0,|L1.332|
0000f0  6800              LDR      r0,[r0,#0]  ; g_execArg
0000f2  b9a8              CBNZ     r0,|L1.288|
;;;87     		cam_getFrameChirp(CAM_GRAB_M1R2, 0, 0, CAM_RES2_WIDTH, CAM_RES2_HEIGHT, g_chirpUsb);
0000f4  2021              MOVS     r0,#0x21
0000f6  9006              STR      r0,[sp,#0x18]
0000f8  2000              MOVS     r0,#0
0000fa  9005              STR      r0,[sp,#0x14]
0000fc  9004              STR      r0,[sp,#0x10]
0000fe  f44f70a0          MOV      r0,#0x140
000102  9003              STR      r0,[sp,#0xc]
000104  20c8              MOVS     r0,#0xc8
000106  9002              STR      r0,[sp,#8]
000108  480e              LDR      r0,|L1.324|
00010a  6800              LDR      r0,[r0,#0]  ; g_chirpUsb
00010c  a902              ADD      r1,sp,#8
00010e  e9cd1000          STRD     r1,r0,[sp,#0]
000112  ab03              ADD      r3,sp,#0xc
000114  aa04              ADD      r2,sp,#0x10
000116  a905              ADD      r1,sp,#0x14
000118  a806              ADD      r0,sp,#0x18
00011a  f7fffffe          BL       _Z17cam_getFrameChirpRKhRKtS2_S2_S2_P5Chirp ; cam_getFrameChirp(const unsigned char&, const unsigned short&, const unsigned short&, const unsigned short&, const unsigned short&, Chirp*)
;;;88     	else 
00011e  e002              B        |L1.294|
                  |L1.288|
;;;89     		sendCMV1();
000120  2001              MOVS     r0,#1
000122  f7fffffe          BL       _Z8sendCMV1h ; sendCMV1(unsigned char)
                  |L1.294|
;;;90     	return 0;
000126  2000              MOVS     r0,#0
;;;91     }
000128  b007              ADD      sp,sp,#0x1c
00012a  bd00              POP      {pc}
;;;92     
                          ENDP

                  |L1.300|
00012c  7369676e          DCB      "signature%d",0
000130  61747572
000134  65256400
                  |L1.312|
                          DCD      g_loadModels
                  |L1.316|
                          DCD      0x10080000
                  |L1.320|
                          DCD      0x31564d43
                  |L1.324|
                          DCD      g_chirpUsb
                  |L1.328|
                          DCD      prevRes
                  |L1.332|
                          DCD      g_execArg

                          AREA ||.ARM.exidx||, LINKORDER=||.text||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||.text||
                          DCD      0x00000001

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  76696465          DCB      "video",0
000004  6f00    
000006  00                DCB      0
000007  00                DCB      0
000008  636f6e74          DCB      "continuous stream of raw camera frames",0
00000c  696e756f
000010  75732073
000014  74726561
000018  6d206f66
00001c  20726177
000020  2063616d
000024  65726120
000028  6672616d
00002c  657300  

                          AREA ||.data||, DATA, ALIGN=2

                  g_loadModels
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  g_progVideo
                          DCD      ||.conststring||
                          DCD      ||.conststring||+0x8
                          DCD      _Z10videoSetupv ; videoSetup()
                          DCD      _Z9videoLoopv ; videoLoop()
                  prevRes
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "progvideo.cpp"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_progvideo_cpp_578abb71___Z7__REV16j|
#line 130 "..\\libpixy\\core_cmInstr.h"
|__asm___13_progvideo_cpp_578abb71___Z7__REV16j| PROC
#line 131

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_progvideo_cpp_578abb71___Z7__REVSHi|
#line 144
|__asm___13_progvideo_cpp_578abb71___Z7__REVSHi| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
