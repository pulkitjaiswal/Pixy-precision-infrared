; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--cpp --list --debug -c --asm --interleave -o.\spifi\blob.o --asm_dir=.\ --list_dir=.\ --depend=.\spifi\blob.d --cpu=Cortex-M4 --apcs=interwork -O0 -I. -I..\libpixy -I..\..\common -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.0\CMSIS\Include -DCORE_M4 -DIPC_MASTER -DPIXY --omf_browse=.\spifi\blob.crf ..\..\common\blob.cpp]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _ZN5CBlob5ResetEv PROC ; CBlob::Reset()
;;;129    void 
;;;130    CBlob::Reset() 
000000  b570              PUSH     {r4-r6,lr}
;;;131    {
000002  4604              MOV      r4,r0
;;;132        // Clear blob data
;;;133        moments.Reset();
000004  bf00              NOP      
000006  2000              MOVS     r0,#0
000008  6220              STR      r0,[r4,#0x20]
00000a  bf00              NOP      
;;;134    
;;;135        // Empty bounds
;;;136        right = -1;
00000c  1e40              SUBS     r0,r0,#1
00000e  82a0              STRH     r0,[r4,#0x14]
;;;137        left = top = 0x7fff;
000010  0c40              LSRS     r0,r0,#17
000012  8260              STRH     r0,[r4,#0x12]
000014  8220              STRH     r0,[r4,#0x10]
;;;138        lastBottom.row = lastBottom.invalid_row;
000016  1181              ASRS     r1,r0,#6
000018  88a0              LDRH     r0,[r4,#4]
00001a  f36100cb          BFI      r0,r1,#3,#9
00001e  80a0              STRH     r0,[r4,#4]
;;;139        nextBottom.row = nextBottom.invalid_row;
000020  8960              LDRH     r0,[r4,#0xa]
000022  f36100cb          BFI      r0,r1,#3,#9
000026  8160              STRH     r0,[r4,#0xa]
;;;140    
;;;141        // Delete segments if any
;;;142        SLinkedSegment *tmp;
;;;143        while(firstSegment!=NULL) {
000028  e005              B        |L1.54|
                  |L1.42|
;;;144            tmp = firstSegment;
00002a  69a5              LDR      r5,[r4,#0x18]
;;;145            firstSegment = tmp->next;
00002c  68a8              LDR      r0,[r5,#8]
00002e  61a0              STR      r0,[r4,#0x18]
;;;146            delete tmp;
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       _ZdlPv ; operator delete (void*)
                  |L1.54|
000036  69a0              LDR      r0,[r4,#0x18]         ;143
000038  2800              CMP      r0,#0                 ;143
00003a  d1f6              BNE      |L1.42|
;;;147        }
;;;148        lastSegmentPtr= &firstSegment;
00003c  f1040018          ADD      r0,r4,#0x18
000040  61e0              STR      r0,[r4,#0x1c]
;;;149    }
000042  bd70              POP      {r4-r6,pc}
;;;150    
                          ENDP

                  _ZN5CBlobC2Ev                  ; Alternate entry point ; CBlob::CBlob__sub_object()
                  _ZN5CBlobC1Ev PROC ; CBlob::CBlob()
;;;110    // CBlob
;;;111    CBlob::CBlob() 
;;;112    {
;;;113        DBG(leakcheck++);
;;;114        // Setup pointers
;;;115        firstSegment= NULL;
;;;116        lastSegmentPtr= &firstSegment;
;;;117    
;;;118        // Reset blob data
;;;119        Reset();
;;;120    }
;;;121    
000044  b510              PUSH     {r4,lr}
000046  4604              MOV      r4,r0
000048  2000              MOVS     r0,#0
00004a  61a0              STR      r0,[r4,#0x18]
00004c  f1040018          ADD      r0,r4,#0x18
000050  61e0              STR      r0,[r4,#0x1c]
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       _ZN5CBlob5ResetEv ; CBlob::Reset()
000058  4620              MOV      r0,r4
00005a  bd10              POP      {r4,pc}
                          ENDP

                  _ZN5CBlobD2Ev                  ; Alternate entry point ; CBlob::~CBlob__sub_object()
                  _ZN5CBlobD1Ev PROC ; CBlob::~CBlob()
;;;122    CBlob::~CBlob() 
;;;123    {
;;;124        DBG(leakcheck--);
;;;125        // Free segments, if any
;;;126        Reset();
;;;127    }
;;;128    
00005c  b510              PUSH     {r4,lr}
00005e  4604              MOV      r4,r0
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       _ZN5CBlob5ResetEv ; CBlob::Reset()
000066  4620              MOV      r0,r4
000068  bd10              POP      {r4,pc}
                          ENDP

                  _ZN5CBlob6NewRowEv PROC ; CBlob::NewRow()
;;;151    void 
;;;152    CBlob::NewRow() 
00006a  8941              LDRH     r1,[r0,#0xa]
;;;153    {
;;;154        if (nextBottom.row != nextBottom.invalid_row) {
00006c  f3c101c8          UBFX     r1,r1,#3,#9
000070  f24012ff          MOV      r2,#0x1ff
000074  4291              CMP      r1,r2
000076  d008              BEQ      |L1.138|
;;;155            lastBottom= nextBottom;
000078  f8d0100a          LDR      r1,[r0,#0xa]
00007c  6041              STR      r1,[r0,#4]
00007e  89c1              LDRH     r1,[r0,#0xe]
000080  8101              STRH     r1,[r0,#8]
;;;156            nextBottom.row= nextBottom.invalid_row;
000082  8941              LDRH     r1,[r0,#0xa]
000084  f36201cb          BFI      r1,r2,#3,#9
000088  8141              STRH     r1,[r0,#0xa]
                  |L1.138|
;;;157        }
;;;158    }
00008a  4770              BX       lr
;;;159    
                          ENDP

                  _ZN5CBlob17UpdateBoundingBoxEiii PROC ; CBlob::UpdateBoundingBox(int, int, int)
;;;231    void 
;;;232    CBlob::UpdateBoundingBox(int newLeft, int newTop, int newRight) 
00008c  b510              PUSH     {r4,lr}
;;;233    {
;;;234        if (newLeft  < left ) left = newLeft;
00008e  f9b04010          LDRSH    r4,[r0,#0x10]
000092  428c              CMP      r4,r1
000094  dd01              BLE      |L1.154|
000096  b20c              SXTH     r4,r1
000098  8204              STRH     r4,[r0,#0x10]
                  |L1.154|
;;;235        if (newTop   < top  ) top  = newTop;
00009a  f9b04012          LDRSH    r4,[r0,#0x12]
00009e  4294              CMP      r4,r2
0000a0  dd01              BLE      |L1.166|
0000a2  b214              SXTH     r4,r2
0000a4  8244              STRH     r4,[r0,#0x12]
                  |L1.166|
;;;236        if (newRight > right) right= newRight;
0000a6  f9b04014          LDRSH    r4,[r0,#0x14]
0000aa  429c              CMP      r4,r3
0000ac  da01              BGE      |L1.178|
0000ae  b21c              SXTH     r4,r3
0000b0  8284              STRH     r4,[r0,#0x14]
                  |L1.178|
;;;237    }
0000b2  bd10              POP      {r4,pc}
;;;238    
                          ENDP

                  _ZN5CBlob3AddERK8SSegment PROC ; CBlob::Add(const SSegment&)
;;;160    void 
;;;161    CBlob::Add(const SSegment &segment) 
0000b4  b5f8              PUSH     {r3-r7,lr}
;;;162    {
0000b6  4604              MOV      r4,r0
0000b8  460d              MOV      r5,r1
;;;163        // Enlarge bounding box if necessary
;;;164        UpdateBoundingBox(segment.startCol, segment.row, segment.endCol);
0000ba  88a8              LDRH     r0,[r5,#4]
0000bc  f3c00309          UBFX     r3,r0,#0,#10
0000c0  8828              LDRH     r0,[r5,#0]
0000c2  f3c002c8          UBFX     r2,r0,#3,#9
0000c6  8868              LDRH     r0,[r5,#2]
0000c8  f3c00109          UBFX     r1,r0,#0,#10
0000cc  4620              MOV      r0,r4
0000ce  f7fffffe          BL       _ZN5CBlob17UpdateBoundingBoxEiii ; CBlob::UpdateBoundingBox(int, int, int)
;;;165    
;;;166        // Update next attachment "surface" at bottom of blob
;;;167        if (nextBottom.row == nextBottom.invalid_row) {
0000d2  8960              LDRH     r0,[r4,#0xa]
0000d4  f3c000c8          UBFX     r0,r0,#3,#9
0000d8  f24011ff          MOV      r1,#0x1ff
0000dc  4288              CMP      r0,r1
0000de  d105              BNE      |L1.236|
;;;168            // New row.
;;;169            nextBottom= segment;
0000e0  6828              LDR      r0,[r5,#0]
0000e2  f8c4000a          STR      r0,[r4,#0xa]
0000e6  88a8              LDRH     r0,[r5,#4]
0000e8  81e0              STRH     r0,[r4,#0xe]
0000ea  e003              B        |L1.244|
                  |L1.236|
;;;170        } else {
;;;171            // Same row.  Add to right side of nextBottom.
;;;172            nextBottom.endCol= segment.endCol;
0000ec  88a8              LDRH     r0,[r5,#4]
0000ee  f3c00009          UBFX     r0,r0,#0,#10
0000f2  81e0              STRH     r0,[r4,#0xe]
                  |L1.244|
;;;173        }
;;;174        
;;;175        SMoments segmentMoments;
;;;176        segment.GetMoments(segmentMoments);
0000f4  bf00              NOP      
0000f6  886a              LDRH     r2,[r5,#2]
0000f8  f3c20209          UBFX     r2,r2,#0,#10
0000fc  1e50              SUBS     r0,r2,#1
0000fe  88aa              LDRH     r2,[r5,#4]
000100  f3c20109          UBFX     r1,r2,#0,#10
000104  1a0a              SUBS     r2,r1,r0
000106  9200              STR      r2,[sp,#0]
000108  bf00              NOP      
;;;177        moments.Add(segmentMoments);
00010a  4669              MOV      r1,sp
00010c  f1040020          ADD      r0,r4,#0x20
000110  f7fffffe          BL       _ZN8SMoments3AddERKS_ ; SMoments::Add(const SMoments&)
;;;178    
;;;179        if (testMoments) {
;;;180    #ifdef INCLUDE_STATS
;;;181            SMoments test;
;;;182            segment.GetMomentsTest(test);
;;;183            assert(test == segmentMoments);
;;;184    #endif
;;;185        }
;;;186        if (recordSegments) {
000114  48f7              LDR      r0,|L1.1268|
000116  7800              LDRB     r0,[r0,#0]  ; _ZN5CBlob14recordSegmentsE
000118  b1d8              CBZ      r0,|L1.338|
;;;187            // Add segment to the _end_ of the linked list
;;;188            *lastSegmentPtr= new (std::nothrow) SLinkedSegment(segment);
00011a  49f7              LDR      r1,|L1.1272|
00011c  200c              MOVS     r0,#0xc
00011e  f7fffffe          BL       _ZnwjRKSt9nothrow_t ; operator new(unsigned, const std::nothrow_t&)
000122  0006              MOVS     r6,r0
000124  d009              BEQ      |L1.314|
000126  4630              MOV      r0,r6
000128  6829              LDR      r1,[r5,#0]
00012a  6001              STR      r1,[r0,#0]
00012c  88a9              LDRH     r1,[r5,#4]
00012e  8081              STRH     r1,[r0,#4]
000130  2100              MOVS     r1,#0
000132  6081              STR      r1,[r0,#8]
000134  bf00              NOP      
000136  4606              MOV      r6,r0
000138  e000              B        |L1.316|
                  |L1.314|
00013a  2000              MOVS     r0,#0
                  |L1.316|
00013c  69e1              LDR      r1,[r4,#0x1c]
00013e  6008              STR      r0,[r1,#0]
;;;189            if (*lastSegmentPtr==NULL)
000140  69e0              LDR      r0,[r4,#0x1c]
000142  6800              LDR      r0,[r0,#0]
000144  b900              CBNZ     r0,|L1.328|
                  |L1.326|
;;;190                return;
;;;191            lastSegmentPtr= &((*lastSegmentPtr)->next);
;;;192        }
;;;193    }
000146  bdf8              POP      {r3-r7,pc}
                  |L1.328|
000148  69e0              LDR      r0,[r4,#0x1c]         ;191
00014a  6800              LDR      r0,[r0,#0]            ;191
00014c  3008              ADDS     r0,r0,#8              ;191
00014e  61e0              STR      r0,[r4,#0x1c]         ;191
000150  bf00              NOP                            ;192
                  |L1.338|
000152  bf00              NOP      
000154  e7f7              B        |L1.326|
;;;194    
                          ENDP

                  _ZN5CBlob10AssimilateERS_ PROC ; CBlob::Assimilate(CBlob&)
;;;207    void 
;;;208    CBlob::Assimilate(CBlob &futileResister) 
000156  b570              PUSH     {r4-r6,lr}
;;;209    {
000158  4605              MOV      r5,r0
00015a  460c              MOV      r4,r1
;;;210        moments.Add(futileResister.moments);
00015c  f1040120          ADD      r1,r4,#0x20
000160  f1050020          ADD      r0,r5,#0x20
000164  f7fffffe          BL       _ZN8SMoments3AddERKS_ ; SMoments::Add(const SMoments&)
;;;211        UpdateBoundingBox(futileResister.left,
000168  f9b43014          LDRSH    r3,[r4,#0x14]
00016c  f9b42012          LDRSH    r2,[r4,#0x12]
000170  f9b41010          LDRSH    r1,[r4,#0x10]
000174  4628              MOV      r0,r5
000176  f7fffffe          BL       _ZN5CBlob17UpdateBoundingBoxEiii ; CBlob::UpdateBoundingBox(int, int, int)
;;;212                          futileResister.top,
;;;213                          futileResister.right);
;;;214        // Update lastBottom
;;;215        if (futileResister.lastBottom.endCol > lastBottom.endCol) {
00017a  8920              LDRH     r0,[r4,#8]
00017c  f3c00109          UBFX     r1,r0,#0,#10
000180  8928              LDRH     r0,[r5,#8]
000182  f3c00009          UBFX     r0,r0,#0,#10
000186  4281              CMP      r1,r0
000188  dd03              BLE      |L1.402|
;;;216            lastBottom.endCol= futileResister.lastBottom.endCol;
00018a  8920              LDRH     r0,[r4,#8]
00018c  f3c00009          UBFX     r0,r0,#0,#10
000190  8128              STRH     r0,[r5,#8]
                  |L1.402|
;;;217        }
;;;218        
;;;219        if (recordSegments) {
000192  48d8              LDR      r0,|L1.1268|
000194  7800              LDRB     r0,[r0,#0]  ; _ZN5CBlob14recordSegmentsE
000196  b148              CBZ      r0,|L1.428|
;;;220            // Take segments from futileResister, append on end
;;;221            *lastSegmentPtr= futileResister.firstSegment;
000198  69a0              LDR      r0,[r4,#0x18]
00019a  69e9              LDR      r1,[r5,#0x1c]
00019c  6008              STR      r0,[r1,#0]
;;;222            lastSegmentPtr= futileResister.lastSegmentPtr;
00019e  69e0              LDR      r0,[r4,#0x1c]
0001a0  61e8              STR      r0,[r5,#0x1c]
;;;223            futileResister.firstSegment= NULL;
0001a2  2000              MOVS     r0,#0
0001a4  61a0              STR      r0,[r4,#0x18]
;;;224            futileResister.lastSegmentPtr= &futileResister.firstSegment;
0001a6  f1040018          ADD      r0,r4,#0x18
0001aa  61e0              STR      r0,[r4,#0x1c]
                  |L1.428|
;;;225            // Futile resister is left with no segments
;;;226        }
;;;227    }
0001ac  bd70              POP      {r4-r6,pc}
;;;228    
                          ENDP

                  _ZN14CBlobAssemblerC2Ev                  ; Alternate entry point ; CBlobAssembler::CBlobAssembler__sub_object()
                  _ZN14CBlobAssemblerC1Ev PROC ; CBlobAssembler::CBlobAssembler()
;;;241    
;;;242    CBlobAssembler::CBlobAssembler() 
;;;243    {
;;;244        activeBlobs= currentBlob= finishedBlobs= NULL;
;;;245        previousBlobPtr= &activeBlobs;
;;;246        currentRow=-1;
;;;247        maxRowDelta=1;
;;;248        m_blobCount=0;
;;;249    }
;;;250    
0001ae  2100              MOVS     r1,#0
0001b0  6101              STR      r1,[r0,#0x10]
0001b2  6081              STR      r1,[r0,#8]
0001b4  6041              STR      r1,[r0,#4]
0001b6  1d01              ADDS     r1,r0,#4
0001b8  60c1              STR      r1,[r0,#0xc]
0001ba  f04f31ff          MOV      r1,#0xffffffff
0001be  8001              STRH     r1,[r0,#0]
0001c0  2101              MOVS     r1,#1
0001c2  8281              STRH     r1,[r0,#0x14]
0001c4  2100              MOVS     r1,#0
0001c6  6181              STR      r1,[r0,#0x18]
0001c8  4770              BX       lr
                          ENDP

                  _ZN14CBlobAssembler5ResetEv PROC ; CBlobAssembler::Reset()
;;;464    
;;;465    void CBlobAssembler::Reset() {
0001ca  b570              PUSH     {r4-r6,lr}
0001cc  4604              MOV      r4,r0
;;;466        assert(!activeBlobs);
0001ce  6860              LDR      r0,[r4,#4]
0001d0  b900              CBNZ     r0,|L1.468|
0001d2  e005              B        |L1.480|
                  |L1.468|
0001d4  f44f72e9          MOV      r2,#0x1d2
0001d8  a1c8              ADR      r1,|L1.1276|
0001da  a0ce              ADR      r0,|L1.1300|
0001dc  f7fffffe          BL       __aeabi_assert
                  |L1.480|
;;;467        currentBlob= NULL;
0001e0  2000              MOVS     r0,#0
0001e2  60a0              STR      r0,[r4,#8]
;;;468        currentRow=-1;
0001e4  1e40              SUBS     r0,r0,#1
0001e6  8020              STRH     r0,[r4,#0]
;;;469        m_blobCount=0;
0001e8  2000              MOVS     r0,#0
0001ea  61a0              STR      r0,[r4,#0x18]
;;;470        while (finishedBlobs) {
0001ec  e00b              B        |L1.518|
                  |L1.494|
;;;471            CBlob *tmp= finishedBlobs->next;
0001ee  6920              LDR      r0,[r4,#0x10]
0001f0  6805              LDR      r5,[r0,#0]
;;;472            delete finishedBlobs;
0001f2  6920              LDR      r0,[r4,#0x10]
0001f4  b128              CBZ      r0,|L1.514|
0001f6  6920              LDR      r0,[r4,#0x10]
0001f8  f7fffffe          BL       _ZN5CBlobD1Ev ; CBlob::~CBlob()
0001fc  4606              MOV      r6,r0
0001fe  f7fffffe          BL       _ZdlPv ; operator delete (void*)
                  |L1.514|
;;;473            finishedBlobs= tmp;
000202  6125              STR      r5,[r4,#0x10]
;;;474        }
000204  bf00              NOP      
                  |L1.518|
000206  6920              LDR      r0,[r4,#0x10]
000208  2800              CMP      r0,#0
00020a  d1f0              BNE      |L1.494|
;;;475        DBG(printf("after CBlobAssember::Reset, leakcheck=%d\n", CBlob::leakcheck));
;;;476    }
00020c  bd70              POP      {r4-r6,pc}
;;;477    
                          ENDP

                  _ZN14CBlobAssembler8EndFrameEv PROC ; CBlobAssembler::EndFrame()
;;;334    // Moves all active blobs to finished list
;;;335    void CBlobAssembler::EndFrame() {
00020e  b510              PUSH     {r4,lr}
000210  4603              MOV      r3,r0
;;;336        while (activeBlobs) {
000212  e00b              B        |L1.556|
                  |L1.532|
;;;337            activeBlobs->NewRow();
000214  6858              LDR      r0,[r3,#4]
000216  f7fffffe          BL       _ZN5CBlob6NewRowEv ; CBlob::NewRow()
;;;338            CBlob *tmp= activeBlobs->next;
00021a  6858              LDR      r0,[r3,#4]
00021c  6804              LDR      r4,[r0,#0]
;;;339            activeBlobs->next= finishedBlobs;
00021e  6859              LDR      r1,[r3,#4]
000220  6918              LDR      r0,[r3,#0x10]
000222  6008              STR      r0,[r1,#0]
;;;340            finishedBlobs= activeBlobs;
000224  6858              LDR      r0,[r3,#4]
000226  6118              STR      r0,[r3,#0x10]
;;;341            activeBlobs= tmp;
000228  605c              STR      r4,[r3,#4]
;;;342        }
00022a  bf00              NOP      
                  |L1.556|
00022c  6858              LDR      r0,[r3,#4]
00022e  2800              CMP      r0,#0
000230  d1f0              BNE      |L1.532|
;;;343    }
000232  bd10              POP      {r4,pc}
;;;344    
                          ENDP

                  _ZN14CBlobAssemblerD2Ev                  ; Alternate entry point ; CBlobAssembler::~CBlobAssembler__sub_object()
                  _ZN14CBlobAssemblerD1Ev PROC ; CBlobAssembler::~CBlobAssembler()
;;;250    
;;;251    CBlobAssembler::~CBlobAssembler() 
;;;252    {
;;;253        // Flush any active blobs into finished blobs
;;;254        EndFrame();
;;;255        // Free any finished blobs
;;;256        Reset();
;;;257    }
;;;258    
000234  b510              PUSH     {r4,lr}
000236  4604              MOV      r4,r0
000238  4620              MOV      r0,r4
00023a  f7fffffe          BL       _ZN14CBlobAssembler8EndFrameEv ; CBlobAssembler::EndFrame()
00023e  4620              MOV      r0,r4
000240  f7fffffe          BL       _ZN14CBlobAssembler5ResetEv ; CBlobAssembler::Reset()
000244  4620              MOV      r0,r4
000246  bd10              POP      {r4,pc}
                          ENDP

                  _ZN14CBlobAssembler10BlobNewRowEPP5CBlob PROC ; CBlobAssembler::BlobNewRow(CBlob**)
;;;502    void 
;;;503    CBlobAssembler::BlobNewRow(CBlob **ptr) 
000248  b530              PUSH     {r4,r5,lr}
;;;504    {
00024a  4603              MOV      r3,r0
00024c  460d              MOV      r5,r1
;;;505        while (*ptr) {
00024e  e015              B        |L1.636|
                  |L1.592|
;;;506            CBlob *blob= *ptr;
000250  682c              LDR      r4,[r5,#0]
;;;507            blob->NewRow();
000252  4620              MOV      r0,r4
000254  f7fffffe          BL       _ZN5CBlob6NewRowEv ; CBlob::NewRow()
;;;508            if (currentRow - blob->lastBottom.row > maxRowDelta) {
000258  f9b30000          LDRSH    r0,[r3,#0]
00025c  88a1              LDRH     r1,[r4,#4]
00025e  f3c101c8          UBFX     r1,r1,#3,#9
000262  1a40              SUBS     r0,r0,r1
000264  f9b31014          LDRSH    r1,[r3,#0x14]
000268  4288              CMP      r0,r1
00026a  dd05              BLE      |L1.632|
;;;509                // Too many rows have elapsed.  Move it to the finished list.
;;;510                *ptr= blob->next;
00026c  6820              LDR      r0,[r4,#0]
00026e  6028              STR      r0,[r5,#0]
;;;511                blob->next= finishedBlobs;
000270  6918              LDR      r0,[r3,#0x10]
000272  6020              STR      r0,[r4,#0]
;;;512                finishedBlobs= blob;
000274  611c              STR      r4,[r3,#0x10]
000276  e000              B        |L1.634|
                  |L1.632|
;;;513            } else {
;;;514                // Blob is valid
;;;515                return;
;;;516            }
;;;517        }
;;;518    }
000278  bd30              POP      {r4,r5,pc}
                  |L1.634|
00027a  bf00              NOP                            ;517
                  |L1.636|
00027c  6828              LDR      r0,[r5,#0]            ;505
00027e  2800              CMP      r0,#0                 ;505
000280  d1e6              BNE      |L1.592|
000282  bf00              NOP      
000284  e7f8              B        |L1.632|
;;;519    
                          ENDP

                  _ZN14CBlobAssembler14AdvanceCurrentEv PROC ; CBlobAssembler::AdvanceCurrent()
;;;530    void 
;;;531    CBlobAssembler::AdvanceCurrent() 
000286  b510              PUSH     {r4,lr}
;;;532    {
000288  4604              MOV      r4,r0
;;;533        previousBlobPtr= &(currentBlob->next);
00028a  68a0              LDR      r0,[r4,#8]
00028c  60e0              STR      r0,[r4,#0xc]
;;;534        currentBlob= *previousBlobPtr;
00028e  68e0              LDR      r0,[r4,#0xc]
000290  6800              LDR      r0,[r0,#0]
000292  60a0              STR      r0,[r4,#8]
;;;535        if (currentBlob) BlobNewRow(&currentBlob->next);
000294  68a0              LDR      r0,[r4,#8]
000296  b118              CBZ      r0,|L1.672|
000298  4620              MOV      r0,r4
00029a  68a1              LDR      r1,[r4,#8]
00029c  f7fffffe          BL       _ZN14CBlobAssembler10BlobNewRowEPP5CBlob ; CBlobAssembler::BlobNewRow(CBlob**)
                  |L1.672|
;;;536    }
0002a0  bd10              POP      {r4,pc}
;;;537    
                          ENDP

                  _ZN14CBlobAssembler13RewindCurrentEv PROC ; CBlobAssembler::RewindCurrent()
;;;520    void 
;;;521    CBlobAssembler::RewindCurrent() 
0002a2  b510              PUSH     {r4,lr}
;;;522    {
0002a4  4604              MOV      r4,r0
;;;523        BlobNewRow(&activeBlobs);
0002a6  1d21              ADDS     r1,r4,#4
0002a8  4620              MOV      r0,r4
0002aa  f7fffffe          BL       _ZN14CBlobAssembler10BlobNewRowEPP5CBlob ; CBlobAssembler::BlobNewRow(CBlob**)
;;;524        previousBlobPtr= &activeBlobs;
0002ae  1d20              ADDS     r0,r4,#4
0002b0  60e0              STR      r0,[r4,#0xc]
;;;525        currentBlob= *previousBlobPtr;
0002b2  68e0              LDR      r0,[r4,#0xc]
0002b4  6800              LDR      r0,[r0,#0]
0002b6  60a0              STR      r0,[r4,#8]
;;;526    
;;;527        if (currentBlob) BlobNewRow(&currentBlob->next);
0002b8  68a0              LDR      r0,[r4,#8]
0002ba  b118              CBZ      r0,|L1.708|
0002bc  4620              MOV      r0,r4
0002be  68a1              LDR      r1,[r4,#8]
0002c0  f7fffffe          BL       _ZN14CBlobAssembler10BlobNewRowEPP5CBlob ; CBlobAssembler::BlobNewRow(CBlob**)
                  |L1.708|
;;;528    }
0002c4  bd10              POP      {r4,pc}
;;;529    
                          ENDP

                  _ZN14CBlobAssembler3AddERK8SSegment PROC ; CBlobAssembler::Add(const SSegment&)
;;;259    // Call once for each segment in the color channel
;;;260    int CBlobAssembler::Add(const SSegment &segment) {
0002c6  e92d47f0          PUSH     {r4-r10,lr}
0002ca  4604              MOV      r4,r0
0002cc  460d              MOV      r5,r1
;;;261        if (segment.row != currentRow) {
0002ce  8828              LDRH     r0,[r5,#0]
0002d0  f3c000c8          UBFX     r0,r0,#3,#9
0002d4  f9b41000          LDRSH    r1,[r4,#0]
0002d8  4288              CMP      r0,r1
0002da  d006              BEQ      |L1.746|
;;;262            // Start new row
;;;263            currentRow= segment.row;
0002dc  8828              LDRH     r0,[r5,#0]
0002de  f3c000c8          UBFX     r0,r0,#3,#9
0002e2  8020              STRH     r0,[r4,#0]
;;;264            RewindCurrent();
0002e4  4620              MOV      r0,r4
0002e6  f7fffffe          BL       _ZN14CBlobAssembler13RewindCurrentEv ; CBlobAssembler::RewindCurrent()
                  |L1.746|
;;;265        }
;;;266        
;;;267        // Try to link this to a previous blob
;;;268        while (currentBlob) {
0002ea  e040              B        |L1.878|
                  |L1.748|
;;;269            if (segment.startCol > currentBlob->lastBottom.endCol) {
0002ec  8868              LDRH     r0,[r5,#2]
0002ee  f3c00109          UBFX     r1,r0,#0,#10
0002f2  68a0              LDR      r0,[r4,#8]
0002f4  8900              LDRH     r0,[r0,#8]
0002f6  f3c00009          UBFX     r0,r0,#0,#10
0002fa  4281              CMP      r1,r0
0002fc  dd03              BLE      |L1.774|
;;;270                // Doesn't connect.  Keep searching more blobs to the right.
;;;271                AdvanceCurrent();
0002fe  4620              MOV      r0,r4
000300  f7fffffe          BL       _ZN14CBlobAssembler14AdvanceCurrentEv ; CBlobAssembler::AdvanceCurrent()
000304  e033              B        |L1.878|
                  |L1.774|
;;;272            } else {
;;;273                if (segment.endCol < currentBlob->lastBottom.startCol) {
000306  88a8              LDRH     r0,[r5,#4]
000308  f3c00109          UBFX     r1,r0,#0,#10
00030c  68a0              LDR      r0,[r4,#8]
00030e  88c0              LDRH     r0,[r0,#6]
000310  f3c00009          UBFX     r0,r0,#0,#10
000314  4281              CMP      r1,r0
000316  da00              BGE      |L1.794|
;;;274                    // Doesn't connect to any blob.  Stop searching.
;;;275                    break;
000318  e02c              B        |L1.884|
                  |L1.794|
;;;276                } else {
;;;277                    // Found a blob to connect to
;;;278                    currentBlob->Add(segment);
00031a  4629              MOV      r1,r5
00031c  68a0              LDR      r0,[r4,#8]
00031e  f7fffffe          BL       _ZN5CBlob3AddERK8SSegment ; CBlob::Add(const SSegment&)
;;;279                    // Check to see if we attach to multiple blobs
;;;280                    while(currentBlob->next &&
000322  e014              B        |L1.846|
                  |L1.804|
;;;281                          segment.endCol >= currentBlob->next->lastBottom.startCol) {
;;;282                        // Can merge the current blob with the next one,
;;;283                        // assimilate the next one and delete it.
;;;284    
;;;285                        // Uncomment this for verbose output for testing
;;;286                        // cout << "Merging blobs:" << endl
;;;287                        //     << " curr: bottom=" << currentBlob->bottom
;;;288                        //     << ", " << currentBlob->lastBottom.startCol
;;;289                        //     << " to " << currentBlob->lastBottom.endCol
;;;290                        //     << ", area " << currentBlob->moments.area << endl
;;;291                        //     << " next: bottom=" << currentBlob->next->bottom
;;;292                        //     << ", " << currentBlob->next->lastBottom.startCol
;;;293                        //     << " to " << currentBlob->next->lastBottom.endCol
;;;294                        //     << ", area " << currentBlob->next->moments.area << endl;
;;;295    
;;;296                        CBlob *futileResister = currentBlob->next;
000324  68a0              LDR      r0,[r4,#8]
000326  6807              LDR      r7,[r0,#0]
;;;297                        // Cut it out of the list
;;;298                        currentBlob->next = futileResister->next;
000328  6838              LDR      r0,[r7,#0]
00032a  68a1              LDR      r1,[r4,#8]
00032c  6008              STR      r0,[r1,#0]
;;;299                        // Assimilate it's segments and moments
;;;300                        currentBlob->Assimilate(*(futileResister));
00032e  4639              MOV      r1,r7
000330  68a0              LDR      r0,[r4,#8]
000332  f7fffffe          BL       _ZN5CBlob10AssimilateERS_ ; CBlob::Assimilate(CBlob&)
;;;301    
;;;302                        // Uncomment this for verbose output for testing
;;;303                        // cout << " NEW curr: bottom=" << currentBlob->bottom
;;;304                        //     << ", " << currentBlob->lastBottom.startCol
;;;305                        //     << " to " << currentBlob->lastBottom.endCol
;;;306                        //     << ", area " << currentBlob->moments.area << endl;
;;;307    
;;;308                        // Delete it
;;;309                        delete futileResister;
000336  b12f              CBZ      r7,|L1.836|
000338  4638              MOV      r0,r7
00033a  f7fffffe          BL       _ZN5CBlobD1Ev ; CBlob::~CBlob()
00033e  4681              MOV      r9,r0
000340  f7fffffe          BL       _ZdlPv ; operator delete (void*)
                  |L1.836|
;;;310    
;;;311                        BlobNewRow(&currentBlob->next);
000344  4620              MOV      r0,r4
000346  68a1              LDR      r1,[r4,#8]
000348  f7fffffe          BL       _ZN14CBlobAssembler10BlobNewRowEPP5CBlob ; CBlobAssembler::BlobNewRow(CBlob**)
;;;312                    }
00034c  bf00              NOP      
                  |L1.846|
00034e  68a0              LDR      r0,[r4,#8]            ;280
000350  6800              LDR      r0,[r0,#0]            ;280
000352  b148              CBZ      r0,|L1.872|
000354  88a8              LDRH     r0,[r5,#4]            ;281
000356  f3c00109          UBFX     r1,r0,#0,#10          ;281
00035a  68a0              LDR      r0,[r4,#8]            ;281
00035c  6800              LDR      r0,[r0,#0]            ;281
00035e  88c0              LDRH     r0,[r0,#6]            ;281
000360  f3c00009          UBFX     r0,r0,#0,#10          ;281
000364  4281              CMP      r1,r0                 ;281
000366  dadd              BGE      |L1.804|
                  |L1.872|
;;;313                    return 0;
000368  2000              MOVS     r0,#0
                  |L1.874|
;;;314                }
;;;315            }
;;;316        }
;;;317        
;;;318        // Could not attach to previous blob, insert new one before currentBlob
;;;319        CBlob *newBlob= new (std::nothrow) CBlob();
;;;320        if (newBlob==NULL)
;;;321        {
;;;322            cprintf("blobs %d\n", m_blobCount);
;;;323            return -1;
;;;324        }
;;;325        m_blobCount++;
;;;326        newBlob->next= currentBlob;
;;;327        *previousBlobPtr= newBlob;
;;;328        previousBlobPtr= &newBlob->next;
;;;329        newBlob->Add(segment);
;;;330        return 0;
;;;331    }
00036a  e8bd87f0          POP      {r4-r10,pc}
                  |L1.878|
00036e  68a0              LDR      r0,[r4,#8]            ;313
000370  2800              CMP      r0,#0                 ;313
000372  d1bb              BNE      |L1.748|
                  |L1.884|
000374  bf00              NOP                            ;275
000376  4960              LDR      r1,|L1.1272|
000378  2024              MOVS     r0,#0x24              ;319
00037a  f7fffffe          BL       _ZnwjRKSt9nothrow_t ; operator new(unsigned, const std::nothrow_t&)
00037e  ea5f0800          MOVS     r8,r0                 ;319
000382  d004              BEQ      |L1.910|
000384  4640              MOV      r0,r8                 ;319
000386  f7fffffe          BL       _ZN5CBlobC1Ev ; CBlob::CBlob()
00038a  4680              MOV      r8,r0                 ;319
00038c  e000              B        |L1.912|
                  |L1.910|
00038e  2000              MOVS     r0,#0                 ;319
                  |L1.912|
000390  4606              MOV      r6,r0                 ;319
000392  b936              CBNZ     r6,|L1.930|
000394  a063              ADR      r0,|L1.1316|
000396  69a1              LDR      r1,[r4,#0x18]         ;322
000398  f7fffffe          BL       _Z7cprintfPKcz ; cprintf(const char*, ...)
00039c  f04f30ff          MOV      r0,#0xffffffff        ;323
0003a0  e7e3              B        |L1.874|
                  |L1.930|
0003a2  69a0              LDR      r0,[r4,#0x18]         ;325
0003a4  1c40              ADDS     r0,r0,#1              ;325
0003a6  61a0              STR      r0,[r4,#0x18]         ;325
0003a8  68a0              LDR      r0,[r4,#8]            ;326
0003aa  6030              STR      r0,[r6,#0]            ;326
0003ac  68e0              LDR      r0,[r4,#0xc]          ;327
0003ae  6006              STR      r6,[r0,#0]            ;327
0003b0  60e6              STR      r6,[r4,#0xc]          ;328
0003b2  4629              MOV      r1,r5                 ;329
0003b4  4630              MOV      r0,r6                 ;329
0003b6  f7fffffe          BL       _ZN5CBlob3AddERK8SSegment ; CBlob::Add(const SSegment&)
0003ba  2000              MOVS     r0,#0                 ;330
0003bc  e7d5              B        |L1.874|
;;;332    
                          ENDP

                  _ZN14CBlobAssembler10ListLengthEPK5CBlob PROC ; CBlobAssembler::ListLength(const CBlob*)
;;;344    
;;;345    int CBlobAssembler::ListLength(const CBlob *b) {
0003be  4602              MOV      r2,r0
;;;346        int len= 0;
0003c0  2000              MOVS     r0,#0
;;;347        while (b) {
0003c2  e001              B        |L1.968|
                  |L1.964|
;;;348            len++;
0003c4  1c40              ADDS     r0,r0,#1
;;;349            b=b->next;
0003c6  6809              LDR      r1,[r1,#0]
                  |L1.968|
0003c8  2900              CMP      r1,#0                 ;347
0003ca  d1fb              BNE      |L1.964|
;;;350        }
;;;351        return len;
;;;352    }
0003cc  4770              BX       lr
;;;353    
                          ENDP

                  _ZN14CBlobAssembler9SplitListEP5CBlobRS1_S2_ PROC ; CBlobAssembler::SplitList(CBlob*, CBlob*&, CBlob*&)
;;;355    // Split a list of blobs into two halves
;;;356    void CBlobAssembler::SplitList(CBlob *all,
0003ce  b570              PUSH     {r4-r6,lr}
;;;357                                   CBlob *&firstHalf, CBlob *&secondHalf) {
0003d0  4605              MOV      r5,r0
0003d2  4614              MOV      r4,r2
;;;358        firstHalf= secondHalf= all;
0003d4  6019              STR      r1,[r3,#0]
0003d6  6021              STR      r1,[r4,#0]
;;;359        CBlob *ptr= all, **nextptr= &secondHalf;
0003d8  4608              MOV      r0,r1
0003da  461a              MOV      r2,r3
;;;360        while (1) {
0003dc  e008              B        |L1.1008|
                  |L1.990|
;;;361            if (!ptr->next) break;
0003de  6806              LDR      r6,[r0,#0]
0003e0  b906              CBNZ     r6,|L1.996|
0003e2  e006              B        |L1.1010|
                  |L1.996|
;;;362            ptr= ptr->next;
0003e4  6800              LDR      r0,[r0,#0]
;;;363            nextptr= &(*nextptr)->next;
0003e6  6812              LDR      r2,[r2,#0]
;;;364            if (!ptr->next) break;
0003e8  6806              LDR      r6,[r0,#0]
0003ea  b906              CBNZ     r6,|L1.1006|
0003ec  e001              B        |L1.1010|
                  |L1.1006|
;;;365            ptr= ptr->next;
0003ee  6800              LDR      r0,[r0,#0]
                  |L1.1008|
0003f0  e7f5              B        |L1.990|
                  |L1.1010|
0003f2  bf00              NOP                            ;361
;;;366        }
;;;367        secondHalf= *nextptr;
0003f4  6816              LDR      r6,[r2,#0]
0003f6  601e              STR      r6,[r3,#0]
;;;368        *nextptr= NULL;
0003f8  2600              MOVS     r6,#0
0003fa  6016              STR      r6,[r2,#0]
;;;369    }
0003fc  bd70              POP      {r4-r6,pc}
;;;370    
                          ENDP

                  _ZN14CBlobAssembler10MergeListsERP5CBlobS2_RPS1_i PROC ; CBlobAssembler::MergeLists(CBlob*&, CBlob*&, CBlob**&, int)
;;;371    // Merge maxelts elements from old1 and old2 into newptr
;;;372    void CBlobAssembler::MergeLists(CBlob *&old1, CBlob *&old2,
0003fe  b5f0              PUSH     {r4-r7,lr}
;;;373                                    CBlob **&newptr, int maxelts) {
000400  4606              MOV      r6,r0
000402  9d05              LDR      r5,[sp,#0x14]
;;;374        int n1= maxelts, n2= maxelts;
000404  462c              MOV      r4,r5
000406  4628              MOV      r0,r5
;;;375        while (1) {
000408  e038              B        |L1.1148|
                  |L1.1034|
;;;376            if (n1 && old1) {
00040a  b334              CBZ      r4,|L1.1114|
00040c  680f              LDR      r7,[r1,#0]
00040e  b327              CBZ      r7,|L1.1114|
;;;377                if (n2 && old2 && old2->moments.area > old1->moments.area) {
000410  b1b0              CBZ      r0,|L1.1088|
000412  6817              LDR      r7,[r2,#0]
000414  b1a7              CBZ      r7,|L1.1088|
000416  6817              LDR      r7,[r2,#0]
000418  6a3f              LDR      r7,[r7,#0x20]
00041a  f8d1c000          LDR      r12,[r1,#0]
00041e  f8dcc020          LDR      r12,[r12,#0x20]
000422  4567              CMP      r7,r12
000424  dd0c              BLE      |L1.1088|
;;;378                    // Choose old2
;;;379                    *newptr= old2;
000426  6817              LDR      r7,[r2,#0]
000428  f8d3c000          LDR      r12,[r3,#0]
00042c  f8cc7000          STR      r7,[r12,#0]
;;;380                    newptr= &(*newptr)->next;
000430  681f              LDR      r7,[r3,#0]
000432  683f              LDR      r7,[r7,#0]
000434  601f              STR      r7,[r3,#0]
;;;381                    old2= *newptr;
000436  681f              LDR      r7,[r3,#0]
000438  683f              LDR      r7,[r7,#0]
00043a  6017              STR      r7,[r2,#0]
;;;382                    --n2;
00043c  1e40              SUBS     r0,r0,#1
00043e  e01d              B        |L1.1148|
                  |L1.1088|
;;;383                } else {
;;;384                    // Choose old1
;;;385                    *newptr= old1;
000440  680f              LDR      r7,[r1,#0]
000442  f8d3c000          LDR      r12,[r3,#0]
000446  f8cc7000          STR      r7,[r12,#0]
;;;386                    newptr= &(*newptr)->next;
00044a  681f              LDR      r7,[r3,#0]
00044c  683f              LDR      r7,[r7,#0]
00044e  601f              STR      r7,[r3,#0]
;;;387                    old1= *newptr;
000450  681f              LDR      r7,[r3,#0]
000452  683f              LDR      r7,[r7,#0]
000454  600f              STR      r7,[r1,#0]
;;;388                    --n1;
000456  1e64              SUBS     r4,r4,#1
000458  e010              B        |L1.1148|
                  |L1.1114|
;;;389                }
;;;390            }
;;;391            else if (n2 && old2) {
00045a  b170              CBZ      r0,|L1.1146|
00045c  6817              LDR      r7,[r2,#0]
00045e  b167              CBZ      r7,|L1.1146|
;;;392                // Choose old2
;;;393                *newptr= old2;
000460  6817              LDR      r7,[r2,#0]
000462  f8d3c000          LDR      r12,[r3,#0]
000466  f8cc7000          STR      r7,[r12,#0]
;;;394                newptr= &(*newptr)->next;
00046a  681f              LDR      r7,[r3,#0]
00046c  683f              LDR      r7,[r7,#0]
00046e  601f              STR      r7,[r3,#0]
;;;395                old2= *newptr;
000470  681f              LDR      r7,[r3,#0]
000472  683f              LDR      r7,[r7,#0]
000474  6017              STR      r7,[r2,#0]
;;;396                --n2;
000476  1e40              SUBS     r0,r0,#1
000478  e000              B        |L1.1148|
                  |L1.1146|
;;;397            } else {
;;;398                // Done
;;;399                return;
;;;400            }
;;;401        }
;;;402    }
00047a  bdf0              POP      {r4-r7,pc}
                  |L1.1148|
00047c  e7c5              B        |L1.1034|
;;;403    
                          ENDP

                  _ZN14CBlobAssembler12SortFinishedEv PROC ; CBlobAssembler::SortFinished()
;;;412    // merge sort (time n log n)
;;;413    void CBlobAssembler::SortFinished() {
00047e  b530              PUSH     {r4,r5,lr}
000480  b087              SUB      sp,sp,#0x1c
000482  4604              MOV      r4,r0
;;;414        // Divide finishedBlobs into two lists
;;;415        CBlob *old1, *old2;
;;;416    
;;;417        if(finishedBlobs == NULL) {
000484  6920              LDR      r0,[r4,#0x10]
000486  b908              CBNZ     r0,|L1.1164|
                  |L1.1160|
;;;418            return;
;;;419        }
;;;420    
;;;421        DBG(int initial_len= ListLength(finishedBlobs));
;;;422        DBG(printf("BSort: Start 0x%x, len=%d\n", finishedBlobs,
;;;423                   initial_len));
;;;424        SplitList(finishedBlobs, old1, old2);
;;;425    
;;;426        // First merge lists of length 1 into sorted lists of length 2
;;;427        // Next, merge sorted lists of length 2 into sorted lists of length 4
;;;428        // And so on.  Terminate when only one merge is performed, which
;;;429        // means we're completely sorted.
;;;430        
;;;431        for (int blocksize= 1; old2; blocksize <<= 1) {
;;;432            CBlob *new1=NULL, *new2=NULL, **newptr1= &new1, **newptr2= &new2;
;;;433            while (old1 || old2) {
;;;434                DBG(printf("BSort: o1 0x%x, o2 0x%x, bs=%d\n",
;;;435                           old1, old2, blocksize));
;;;436                DBG(printf("       n1 0x%x, n2 0x%x\n",
;;;437                           new1, new2));
;;;438                MergeLists(old1, old2, newptr1, blocksize);
;;;439                MergeLists(old1, old2, newptr2, blocksize);
;;;440            }
;;;441            *newptr1= *newptr2= NULL; // Terminate lists
;;;442            old1= new1;
;;;443            old2= new2;
;;;444        }
;;;445        finishedBlobs= old1;
;;;446        DBG(AssertFinishedSorted());
;;;447        DBG(int final_len= ListLength(finishedBlobs));
;;;448        DBG(printf("BSort: DONE  0x%x, len=%d\n", finishedBlobs,
;;;449                   ListLength(finishedBlobs)));
;;;450        DBG(if (final_len != initial_len) len_error());
;;;451    }
000488  b007              ADD      sp,sp,#0x1c
00048a  bd30              POP      {r4,r5,pc}
                  |L1.1164|
00048c  ab05              ADD      r3,sp,#0x14           ;424
00048e  aa06              ADD      r2,sp,#0x18           ;424
000490  4620              MOV      r0,r4                 ;424
000492  6921              LDR      r1,[r4,#0x10]         ;424
000494  f7fffffe          BL       _ZN14CBlobAssembler9SplitListEP5CBlobRS1_S2_ ; CBlobAssembler::SplitList(CBlob*, CBlob*&, CBlob*&)
000498  2501              MOVS     r5,#1                 ;431
00049a  e024              B        |L1.1254|
                  |L1.1180|
00049c  2000              MOVS     r0,#0                 ;432
00049e  9004              STR      r0,[sp,#0x10]         ;432
0004a0  9003              STR      r0,[sp,#0xc]          ;432
0004a2  a804              ADD      r0,sp,#0x10           ;432
0004a4  9002              STR      r0,[sp,#8]            ;432
0004a6  a803              ADD      r0,sp,#0xc            ;432
0004a8  9001              STR      r0,[sp,#4]            ;432
0004aa  e00d              B        |L1.1224|
                  |L1.1196|
0004ac  ab02              ADD      r3,sp,#8              ;438
0004ae  aa05              ADD      r2,sp,#0x14           ;438
0004b0  a906              ADD      r1,sp,#0x18           ;438
0004b2  4620              MOV      r0,r4                 ;438
0004b4  9500              STR      r5,[sp,#0]            ;438
0004b6  f7fffffe          BL       _ZN14CBlobAssembler10MergeListsERP5CBlobS2_RPS1_i ; CBlobAssembler::MergeLists(CBlob*&, CBlob*&, CBlob**&, int)
0004ba  ab01              ADD      r3,sp,#4              ;439
0004bc  aa05              ADD      r2,sp,#0x14           ;439
0004be  a906              ADD      r1,sp,#0x18           ;439
0004c0  4620              MOV      r0,r4                 ;439
0004c2  9500              STR      r5,[sp,#0]            ;439
0004c4  f7fffffe          BL       _ZN14CBlobAssembler10MergeListsERP5CBlobS2_RPS1_i ; CBlobAssembler::MergeLists(CBlob*&, CBlob*&, CBlob**&, int)
                  |L1.1224|
0004c8  9806              LDR      r0,[sp,#0x18]         ;433
0004ca  2800              CMP      r0,#0                 ;433
0004cc  d1ee              BNE      |L1.1196|
0004ce  9805              LDR      r0,[sp,#0x14]         ;433
0004d0  2800              CMP      r0,#0                 ;433
0004d2  d1eb              BNE      |L1.1196|
0004d4  9901              LDR      r1,[sp,#4]            ;441
0004d6  6008              STR      r0,[r1,#0]            ;441
0004d8  9902              LDR      r1,[sp,#8]            ;441
0004da  6008              STR      r0,[r1,#0]            ;441
0004dc  9804              LDR      r0,[sp,#0x10]         ;442
0004de  9006              STR      r0,[sp,#0x18]         ;442
0004e0  9803              LDR      r0,[sp,#0xc]          ;443
0004e2  9005              STR      r0,[sp,#0x14]         ;443
0004e4  006d              LSLS     r5,r5,#1              ;431
                  |L1.1254|
0004e6  9805              LDR      r0,[sp,#0x14]         ;431
0004e8  2800              CMP      r0,#0                 ;431
0004ea  d1d7              BNE      |L1.1180|
0004ec  9806              LDR      r0,[sp,#0x18]         ;445
0004ee  6120              STR      r0,[r4,#0x10]         ;445
0004f0  bf00              NOP      
0004f2  e7c9              B        |L1.1160|
                  |L1.1268|
                          DCD      _ZN5CBlob14recordSegmentsE ; CBlob::recordSegments
                  |L1.1272|
                          DCD      _ZSt7nothrow ; std::nothrow
                  |L1.1276|
0004fc  2e2e5c2e          DCB      "..\\..\\common\\blob.cpp",0
000500  2e5c636f
000504  6d6d6f6e
000508  5c626c6f
00050c  622e6370
000510  7000    
000512  00                DCB      0
000513  00                DCB      0
                  |L1.1300|
000514  21616374          DCB      "!activeBlobs",0
000518  69766542
00051c  6c6f6273
000520  00      
000521  00                DCB      0
000522  00                DCB      0
000523  00                DCB      0
                  |L1.1316|
000524  626c6f62          DCB      "blobs %d\n",0
000528  73202564
00052c  0a00    
00052e  00                DCB      0
00052f  00                DCB      0
                          ENDP

                  _ZN14CBlobAssembler20AssertFinishedSortedEv PROC ; CBlobAssembler::AssertFinishedSorted()
;;;453    // Assert that finishedBlobs is in fact sorted.  For testing only.
;;;454    void CBlobAssembler::AssertFinishedSorted() {
000530  b570              PUSH     {r4-r6,lr}
000532  4606              MOV      r6,r0
;;;455        if (!finishedBlobs) return;
000534  6930              LDR      r0,[r6,#0x10]
000536  b900              CBNZ     r0,|L1.1338|
                  |L1.1336|
;;;456        CBlob *i= finishedBlobs;
;;;457        CBlob *j= i->next;
;;;458        while (j) {
;;;459            assert(i->moments.area >= j->moments.area);
;;;460            i= j;
;;;461            j= i->next;
;;;462        }
;;;463    }
000538  bd70              POP      {r4-r6,pc}
                  |L1.1338|
00053a  6935              LDR      r5,[r6,#0x10]         ;456
00053c  682c              LDR      r4,[r5,#0]            ;457
00053e  e00d              B        |L1.1372|
                  |L1.1344|
000540  6a28              LDR      r0,[r5,#0x20]         ;459
000542  6a21              LDR      r1,[r4,#0x20]         ;459
000544  4288              CMP      r0,r1                 ;459
000546  db00              BLT      |L1.1354|
000548  e006              B        |L1.1368|
                  |L1.1354|
00054a  f24012cb          MOV      r2,#0x1cb             ;459
00054e  f2af0154          ADR      r1,|L1.1276|
000552  a004              ADR      r0,|L1.1380|
000554  f7fffffe          BL       __aeabi_assert
                  |L1.1368|
000558  4625              MOV      r5,r4                 ;460
00055a  682c              LDR      r4,[r5,#0]            ;461
                  |L1.1372|
00055c  2c00              CMP      r4,#0                 ;458
00055e  d1ef              BNE      |L1.1344|
000560  bf00              NOP      
000562  e7e9              B        |L1.1336|
;;;464    
                          ENDP

                  |L1.1380|
000564  692d3e6d          DCB      "i->moments.area >= j->moments.area",0
000568  6f6d656e
00056c  74732e61
000570  72656120
000574  3e3d206a
000578  2d3e6d6f
00057c  6d656e74
000580  732e6172
000584  656100  
000587  00                DCB      0

                          AREA ||.ARM.exidx||, LINKORDER=||.text||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||.text||
                          DCD      0x00000001

                          AREA ||.data||, DATA, ALIGN=2

                  _ZN8SMoments11computeAxesE ; SMoments::computeAxes
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  _ZN5CBlob9leakcheckE ; CBlob::leakcheck
                          DCD      0x00000000
                  _ZN5CBlob14recordSegmentsE ; CBlob::recordSegments
000008  00                DCB      0x00
                  _ZN5CBlob11testMomentsE ; CBlob::testMoments
000009  00                DCB      0x00

                          AREA ||i._ZN8SMoments3AddERKS_||, COMGROUP=_ZN8SMoments3AddERKS_, CODE, READONLY, ALIGN=1

                  _ZN8SMoments3AddERKS_ PROC ; SMoments::Add(const SMoments&)
;;;100    #endif
;;;101        void Add(const SMoments &moments) {
000000  6802              LDR      r2,[r0,#0]
;;;102            area += moments.area;
000002  680b              LDR      r3,[r1,#0]
000004  441a              ADD      r2,r2,r3
000006  6002              STR      r2,[r0,#0]
;;;103    #ifdef INCLUDE_STATS
;;;104            sumX += moments.sumX;
;;;105            sumY += moments.sumY;
;;;106            if (computeAxes) {
;;;107                sumXX += moments.sumXX;
;;;108                sumYY += moments.sumYY;
;;;109                sumXY += moments.sumXY;
;;;110            }
;;;111    #endif
;;;112        }
000008  4770              BX       lr
;;;113    #ifdef INCLUDE_STATS
                          ENDP


                          AREA ||area_number.16||, COMGROUP=_ZN8SMoments3AddERKS_, LINKORDER=||i._ZN8SMoments3AddERKS_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.16||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN8SMoments3AddERKS_||
                          DCD      0x00000001

;*** Start embedded assembler ***

#line 1 "..\\..\\common\\blob.cpp"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___8_blob_cpp_421c5bba___Z7__REV16j|
#line 130 "..\\libpixy\\core_cmInstr.h"
|__asm___8_blob_cpp_421c5bba___Z7__REV16j| PROC
#line 131

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___8_blob_cpp_421c5bba___Z7__REVSHi|
#line 144
|__asm___8_blob_cpp_421c5bba___Z7__REVSHi| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
