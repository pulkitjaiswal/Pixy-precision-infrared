; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--cpp --list --debug -c --asm --interleave -o.\spifi\uart.o --asm_dir=.\ --list_dir=.\ --depend=.\spifi\uart.d --cpu=Cortex-M4 --apcs=interwork -O0 -I. -I..\libpixy -I..\..\common -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.0\CMSIS\Include -DCORE_M4 -DIPC_MASTER -DPIXY --omf_browse=.\spifi\uart.crf ..\libpixy\uart.cpp]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _ZN4Uart10irqHandlerEv PROC ; Uart::irqHandler()
;;;29     
;;;30     void Uart::irqHandler()
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;31     {
000004  4604              MOV      r4,r0
;;;32     	uint32_t status;
;;;33     	uint8_t i, c;
;;;34     	volatile uint32_t v;
;;;35     
;;;36     	m_flag = false;
000006  2000              MOVS     r0,#0
000008  f8840034          STRB     r0,[r4,#0x34]
;;;37     
;;;38     	/* Determine the interrupt source */
;;;39     	status = m_uart->IIR & UART_IIR_INTID_MASK;
00000c  6860              LDR      r0,[r4,#4]
00000e  6880              LDR      r0,[r0,#8]
000010  f000060e          AND      r6,r0,#0xe
;;;40     
;;;41     	if (status==UART_IIR_INTID_RDA) // Receive Data Available 
000014  2e04              CMP      r6,#4
000016  d11f              BNE      |L1.88|
;;;42     		m_rq.write(m_uart->RBR&UART_RBR_MASKBIT);
000018  f1040508          ADD      r5,r4,#8
00001c  6860              LDR      r0,[r4,#4]
00001e  6800              LDR      r0,[r0,#0]
000020  f00008ff          AND      r8,r0,#0xff
000024  bf00              NOP      
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       _ZN8ReceiveQIhE10receiveLenEv ; ReceiveQ<unsigned char>::receiveLen()
00002c  6829              LDR      r1,[r5,#0]
00002e  1a08              SUBS     r0,r1,r0
000030  2800              CMP      r0,#0
000032  dc00              BGT      |L1.54|
000034  e00f              B        |L1.86|
                  |L1.54|
000036  68e9              LDR      r1,[r5,#0xc]
000038  1c48              ADDS     r0,r1,#1
00003a  60e8              STR      r0,[r5,#0xc]
00003c  6868              LDR      r0,[r5,#4]
00003e  f8008001          STRB     r8,[r0,r1]
000042  6928              LDR      r0,[r5,#0x10]
000044  1c40              ADDS     r0,r0,#1
000046  6128              STR      r0,[r5,#0x10]
000048  6829              LDR      r1,[r5,#0]
00004a  68e8              LDR      r0,[r5,#0xc]
00004c  4288              CMP      r0,r1
00004e  d101              BNE      |L1.84|
000050  2000              MOVS     r0,#0
000052  60e8              STR      r0,[r5,#0xc]
                  |L1.84|
000054  bf00              NOP      
                  |L1.86|
000056  e02d              B        |L1.180|
                  |L1.88|
;;;43     	else if (status==UART_IIR_INTID_CTI)
000058  2e0c              CMP      r6,#0xc
00005a  d103              BNE      |L1.100|
;;;44     		v = m_uart->RBR; // toss...
00005c  6860              LDR      r0,[r4,#4]
00005e  6800              LDR      r0,[r0,#0]
000060  9000              STR      r0,[sp,#0]
000062  e027              B        |L1.180|
                  |L1.100|
;;;45     	else if (status==UART_IIR_INTID_THRE) // Transmit Holding Empty
000064  2e02              CMP      r6,#2
000066  d125              BNE      |L1.180|
;;;46     	{
;;;47     		for (i=0; i<UART_TX_FIFO_SIZE; i++) // fill transmit FIFO
000068  2700              MOVS     r7,#0
00006a  e021              B        |L1.176|
                  |L1.108|
;;;48     		{
;;;49     			if (m_tq.read(&c))
00006c  bf00              NOP      
00006e  6ae0              LDR      r0,[r4,#0x2c]
000070  b950              CBNZ     r0,|L1.136|
000072  6b22              LDR      r2,[r4,#0x30]
000074  e9d41008          LDRD     r1,r0,[r4,#0x20]
000078  4790              BLX      r2
00007a  62e0              STR      r0,[r4,#0x2c]
00007c  6ae0              LDR      r0,[r4,#0x2c]
00007e  b908              CBNZ     r0,|L1.132|
000080  2000              MOVS     r0,#0
000082  e00b              B        |L1.156|
                  |L1.132|
000084  2000              MOVS     r0,#0
000086  62a0              STR      r0,[r4,#0x28]
                  |L1.136|
000088  6aa1              LDR      r1,[r4,#0x28]
00008a  1c48              ADDS     r0,r1,#1
00008c  62a0              STR      r0,[r4,#0x28]
00008e  6a60              LDR      r0,[r4,#0x24]
000090  5c40              LDRB     r0,[r0,r1]
000092  9001              STR      r0,[sp,#4]
000094  6ae0              LDR      r0,[r4,#0x2c]
000096  1e40              SUBS     r0,r0,#1
000098  62e0              STR      r0,[r4,#0x2c]
00009a  2001              MOVS     r0,#1
                  |L1.156|
00009c  b130              CBZ      r0,|L1.172|
;;;50     			{
;;;51     				m_flag = true;
00009e  2001              MOVS     r0,#1
0000a0  f8840034          STRB     r0,[r4,#0x34]
;;;52     				m_uart->THR = c;
0000a4  f89d0004          LDRB     r0,[sp,#4]
0000a8  6861              LDR      r1,[r4,#4]
0000aa  6008              STR      r0,[r1,#0]
                  |L1.172|
0000ac  1c78              ADDS     r0,r7,#1              ;47
0000ae  b2c7              UXTB     r7,r0                 ;47
                  |L1.176|
0000b0  2f10              CMP      r7,#0x10              ;47
0000b2  dbdb              BLT      |L1.108|
                  |L1.180|
;;;53     			}
;;;54     		}
;;;55     	}
;;;56     }
0000b4  e8bd81fc          POP      {r2-r8,pc}
;;;57     
                          ENDP

                  UART0_IRQHandler PROC
;;;24     
;;;25     void UART0_IRQHandler(void)
0000b8  b510              PUSH     {r4,lr}
;;;26     {
;;;27     	g_uart0->irqHandler();
0000ba  4885              LDR      r0,|L1.720|
0000bc  6800              LDR      r0,[r0,#0]  ; g_uart0
0000be  f7fffffe          BL       _ZN4Uart10irqHandlerEv ; Uart::irqHandler()
;;;28     }
0000c2  bd10              POP      {r4,pc}
;;;29     
                          ENDP

                  _ZN4UartC2EP15LPC_USARTn_TypePFjPhjE                  ; Alternate entry point ; Uart::Uart__sub_object(LPC_USARTn_Type*, unsigned(*)(unsigned char*, unsigned))
                  _ZN4UartC1EP15LPC_USARTn_TypePFjPhjE PROC ; Uart::Uart(LPC_USARTn_Type*, unsigned(*)(unsigned char*, unsigned))
;;;112    
;;;113    Uart::Uart(LPC_USARTn_Type *uart,  SerialCallback callback) : m_rq(UART_RECEIVE_BUF_SIZE), m_tq(UART_TRANSMIT_BUF_SIZE, callback)
;;;114    {
;;;115    	UART_FIFO_CFG_Type ufifo;
;;;116    	UART_CFG_Type ucfg;
;;;117    
;;;118    	m_uart = uart;
;;;119    	m_flag = false;
;;;120    	 	
;;;121    	// regular config			 
;;;122    	ucfg.Baud_rate = UART_DEFAULT_BAUDRATE;
;;;123    	ucfg.Databits = UART_DATABIT_8;
;;;124    	ucfg.Parity = UART_PARITY_NONE;
;;;125    	ucfg.Stopbits = UART_STOPBIT_1;
;;;126    	ucfg.Clock_Speed = CLKFREQ;
;;;127    
;;;128    	UART_Init(m_uart, &ucfg);
;;;129    
;;;130    	// config FIFOs
;;;131    	ufifo.FIFO_DMAMode = DISABLE;
;;;132    	ufifo.FIFO_Level = UART_FIFO_TRGLEV0;
;;;133    	ufifo.FIFO_ResetRxBuf = ENABLE;
;;;134    	ufifo.FIFO_ResetTxBuf = ENABLE;
;;;135    
;;;136    	UART_FIFOConfig(m_uart, &ufifo);
;;;137    	UART_TxCmd(m_uart, ENABLE);
;;;138    
;;;139    	// enable interrupts
;;;140    	UART_IntConfig(m_uart, UART_INTCFG_RBR, ENABLE);
;;;141    	UART_IntConfig(m_uart, UART_INTCFG_THRE, ENABLE);
;;;142    
;;;143        NVIC_SetPriority(USART0_IRQn, 0);
;;;144    }
;;;145    
0000c4  e92d41ff          PUSH     {r0-r8,lr}
0000c8  4604              MOV      r4,r0
0000ca  460f              MOV      r7,r1
0000cc  4616              MOV      r6,r2
0000ce  4981              LDR      r1,|L1.724|
0000d0  4881              LDR      r0,|L1.728|
0000d2  6020              STR      r0,[r4,#0]
0000d4  f1040508          ADD      r5,r4,#8
0000d8  f04f0820          MOV      r8,#0x20
0000dc  f8c58000          STR      r8,[r5,#0]
0000e0  6828              LDR      r0,[r5,#0]
0000e2  f7fffffe          BL       _Znaj ; operator new[] (unsigned)
0000e6  6068              STR      r0,[r5,#4]
0000e8  2000              MOVS     r0,#0
0000ea  60a8              STR      r0,[r5,#8]
0000ec  60e8              STR      r0,[r5,#0xc]
0000ee  6128              STR      r0,[r5,#0x10]
0000f0  6168              STR      r0,[r5,#0x14]
0000f2  bf00              NOP      
0000f4  f1a50408          SUB      r4,r5,#8
0000f8  f1040520          ADD      r5,r4,#0x20
0000fc  f8c58000          STR      r8,[r5,#0]
000100  6828              LDR      r0,[r5,#0]
000102  f7fffffe          BL       _Znaj ; operator new[] (unsigned)
000106  6068              STR      r0,[r5,#4]
000108  2000              MOVS     r0,#0
00010a  60a8              STR      r0,[r5,#8]
00010c  60e8              STR      r0,[r5,#0xc]
00010e  612e              STR      r6,[r5,#0x10]
000110  bf00              NOP      
000112  f1a50420          SUB      r4,r5,#0x20
000116  6067              STR      r7,[r4,#4]
000118  f8840034          STRB     r0,[r4,#0x34]
00011c  f44f4096          MOV      r0,#0x4b00
000120  9000              STR      r0,[sp,#0]
000122  2003              MOVS     r0,#3
000124  f88d0005          STRB     r0,[sp,#5]
000128  2000              MOVS     r0,#0
00012a  f88d0004          STRB     r0,[sp,#4]
00012e  f88d0006          STRB     r0,[sp,#6]
000132  486a              LDR      r0,|L1.732|
000134  9002              STR      r0,[sp,#8]
000136  4669              MOV      r1,sp
000138  6860              LDR      r0,[r4,#4]
00013a  f7fffffe          BL       UART_Init
00013e  2000              MOVS     r0,#0
000140  f88d000e          STRB     r0,[sp,#0xe]
000144  f88d000f          STRB     r0,[sp,#0xf]
000148  2001              MOVS     r0,#1
00014a  f88d000c          STRB     r0,[sp,#0xc]
00014e  f88d000d          STRB     r0,[sp,#0xd]
000152  a903              ADD      r1,sp,#0xc
000154  6860              LDR      r0,[r4,#4]
000156  f7fffffe          BL       UART_FIFOConfig
00015a  2101              MOVS     r1,#1
00015c  6860              LDR      r0,[r4,#4]
00015e  f7fffffe          BL       UART_TxCmd
000162  2201              MOVS     r2,#1
000164  2100              MOVS     r1,#0
000166  6860              LDR      r0,[r4,#4]
000168  f7fffffe          BL       UART_IntConfig
00016c  2201              MOVS     r2,#1
00016e  4611              MOV      r1,r2
000170  6860              LDR      r0,[r4,#4]
000172  f7fffffe          BL       UART_IntConfig
000176  2018              MOVS     r0,#0x18
000178  2100              MOVS     r1,#0
00017a  2800              CMP      r0,#0
00017c  da07              BGE      |L1.398|
00017e  070a              LSLS     r2,r1,#28
000180  0e15              LSRS     r5,r2,#24
000182  4a57              LDR      r2,|L1.736|
000184  f000030f          AND      r3,r0,#0xf
000188  1f1b              SUBS     r3,r3,#4
00018a  54d5              STRB     r5,[r2,r3]
00018c  e003              B        |L1.406|
                  |L1.398|
00018e  070a              LSLS     r2,r1,#28
000190  0e13              LSRS     r3,r2,#24
000192  4a54              LDR      r2,|L1.740|
000194  5413              STRB     r3,[r2,r0]
                  |L1.406|
000196  bf00              NOP      
000198  4620              MOV      r0,r4
00019a  b004              ADD      sp,sp,#0x10
00019c  e8bd81f0          POP      {r4-r8,pc}
                          ENDP

                  _Z9uart_initPFjPhjE PROC ; uart_init(unsigned(*)(unsigned char*, unsigned))
;;;151    
;;;152    void uart_init(SerialCallback callback)
0001a0  b570              PUSH     {r4-r6,lr}
;;;153    {
0001a2  4604              MOV      r4,r0
;;;154    	g_uart0 = new Uart(LPC_USART0, callback);
0001a4  2038              MOVS     r0,#0x38
0001a6  f7fffffe          BL       _Znwj ; operator new(unsigned)
0001aa  4605              MOV      r5,r0
0001ac  4622              MOV      r2,r4
0001ae  494e              LDR      r1,|L1.744|
0001b0  f7fffffe          BL       _ZN4UartC1EP15LPC_USARTn_TypePFjPhjE ; Uart::Uart(LPC_USARTn_Type*, unsigned(*)(unsigned char*, unsigned))
0001b4  4605              MOV      r5,r0
0001b6  4846              LDR      r0,|L1.720|
0001b8  6005              STR      r5,[r0,#0]  ; g_uart0
;;;155    }
0001ba  bd70              POP      {r4-r6,pc}
                          ENDP

                  _ZN4Uart4openEv PROC ; Uart::open()
;;;57     
;;;58     int Uart::open()
0001bc  b510              PUSH     {r4,lr}
;;;59     {
0001be  4604              MOV      r4,r0
;;;60     	scu_pinmux(0x2, 0, (MD_PLN | MD_EZI | MD_ZI | MD_EHS), FUNC1); 	         // U0_TXD 
0001c0  2301              MOVS     r3,#1
0001c2  22f0              MOVS     r2,#0xf0
0001c4  2100              MOVS     r1,#0
0001c6  2002              MOVS     r0,#2
0001c8  f7fffffe          BL       scu_pinmux
;;;61     	scu_pinmux(0x2, 1, (MD_PLN | MD_EZI | MD_ZI | MD_EHS), FUNC1); 	         // U0_RXD
0001cc  2301              MOVS     r3,#1
0001ce  22f0              MOVS     r2,#0xf0
0001d0  4619              MOV      r1,r3
0001d2  2002              MOVS     r0,#2
0001d4  f7fffffe          BL       scu_pinmux
;;;62      	scu_pinmux(0x1, 3, (MD_PLN | MD_EZI | MD_ZI | MD_EHS), FUNC0); 	         // turn SSP1_MISO into GPIO0[10]
0001d8  2300              MOVS     r3,#0
0001da  22f0              MOVS     r2,#0xf0
0001dc  2103              MOVS     r1,#3
0001de  2001              MOVS     r0,#1
0001e0  f7fffffe          BL       scu_pinmux
;;;63     	scu_pinmux(0x1, 4, (MD_PLN | MD_EZI | MD_ZI | MD_EHS), FUNC0); 	         // turn SSP1_MOSI into GPIO0[11]
0001e4  2300              MOVS     r3,#0
0001e6  22f0              MOVS     r2,#0xf0
0001e8  2104              MOVS     r1,#4
0001ea  2001              MOVS     r0,#1
0001ec  f7fffffe          BL       scu_pinmux
;;;64     
;;;65         NVIC_EnableIRQ(USART0_IRQn);
0001f0  2018              MOVS     r0,#0x18
0001f2  2101              MOVS     r1,#1
0001f4  4081              LSLS     r1,r1,r0
0001f6  0942              LSRS     r2,r0,#5
0001f8  0092              LSLS     r2,r2,#2
0001fa  f10222e0          ADD      r2,r2,#0xe000e000
0001fe  f8c21100          STR      r1,[r2,#0x100]
000202  bf00              NOP      
;;;66     	return 0;
000204  2000              MOVS     r0,#0
;;;67     }
000206  bd10              POP      {r4,pc}
;;;68     
                          ENDP

                  _ZN4Uart5closeEv PROC ; Uart::close()
;;;69     int Uart::close()
000208  b510              PUSH     {r4,lr}
;;;70     {
00020a  4604              MOV      r4,r0
;;;71     	scu_pinmux(0x2, 0, (MD_PLN | MD_EZI | MD_ZI | MD_EHS), FUNC4); 	         // U0_TXD 
00020c  2304              MOVS     r3,#4
00020e  22f0              MOVS     r2,#0xf0
000210  2100              MOVS     r1,#0
000212  2002              MOVS     r0,#2
000214  f7fffffe          BL       scu_pinmux
;;;72     	scu_pinmux(0x2, 1, (MD_PLN | MD_EZI | MD_ZI | MD_EHS), FUNC4); 	         // U0_RXD
000218  2304              MOVS     r3,#4
00021a  22f0              MOVS     r2,#0xf0
00021c  2101              MOVS     r1,#1
00021e  2002              MOVS     r0,#2
000220  f7fffffe          BL       scu_pinmux
;;;73     
;;;74     	NVIC_DisableIRQ(USART0_IRQn);
000224  2018              MOVS     r0,#0x18
000226  2101              MOVS     r1,#1
000228  4081              LSLS     r1,r1,r0
00022a  4a30              LDR      r2,|L1.748|
00022c  0943              LSRS     r3,r0,#5
00022e  f8421023          STR      r1,[r2,r3,LSL #2]
000232  bf00              NOP      
;;;75     	return 0;
000234  2000              MOVS     r0,#0
;;;76     }
000236  bd10              POP      {r4,pc}
;;;77     
                          ENDP

                  _ZN4Uart7receiveEPhj PROC ; Uart::receive(unsigned char*, unsigned)
;;;78     int Uart::receive(uint8_t *buf, uint32_t len)
000238  e92d43f8          PUSH     {r3-r9,lr}
;;;79     {
00023c  4680              MOV      r8,r0
00023e  460e              MOV      r6,r1
000240  4617              MOV      r7,r2
;;;80     	uint32_t i;
;;;81     	uint8_t buf8;
;;;82     
;;;83       if (buf == 0) {
000242  b916              CBNZ     r6,|L1.586|
;;;84         return 0;
000244  2000              MOVS     r0,#0
                  |L1.582|
;;;85       }
;;;86     
;;;87     	for (i=0; i<len; i++)
;;;88     	{
;;;89     		if (m_rq.read(&buf8)==0)
;;;90     			break;
;;;91     		buf[i] = buf8;
;;;92     	}
;;;93     
;;;94     	return i;
;;;95     }
000246  e8bd83f8          POP      {r3-r9,pc}
                  |L1.586|
00024a  2500              MOVS     r5,#0                 ;87
00024c  e01e              B        |L1.652|
                  |L1.590|
00024e  f1080408          ADD      r4,r8,#8              ;89
000252  4620              MOV      r0,r4                 ;89
000254  f7fffffe          BL       _ZN8ReceiveQIhE10receiveLenEv ; ReceiveQ<unsigned char>::receiveLen()
000258  2800              CMP      r0,#0                 ;89
00025a  dc01              BGT      |L1.608|
00025c  2000              MOVS     r0,#0                 ;89
00025e  e00f              B        |L1.640|
                  |L1.608|
000260  68a1              LDR      r1,[r4,#8]            ;89
000262  1c48              ADDS     r0,r1,#1              ;89
000264  60a0              STR      r0,[r4,#8]            ;89
000266  6860              LDR      r0,[r4,#4]            ;89
000268  5c40              LDRB     r0,[r0,r1]            ;89
00026a  9000              STR      r0,[sp,#0]            ;89
00026c  6960              LDR      r0,[r4,#0x14]         ;89
00026e  1c40              ADDS     r0,r0,#1              ;89
000270  6160              STR      r0,[r4,#0x14]         ;89
000272  6821              LDR      r1,[r4,#0]            ;89
000274  68a0              LDR      r0,[r4,#8]            ;89
000276  4288              CMP      r0,r1                 ;89
000278  d101              BNE      |L1.638|
00027a  2000              MOVS     r0,#0                 ;89
00027c  60a0              STR      r0,[r4,#8]            ;89
                  |L1.638|
00027e  2001              MOVS     r0,#1                 ;89
                  |L1.640|
000280  b900              CBNZ     r0,|L1.644|
000282  e005              B        |L1.656|
                  |L1.644|
000284  f89d0000          LDRB     r0,[sp,#0]            ;91
000288  5570              STRB     r0,[r6,r5]            ;91
00028a  1c6d              ADDS     r5,r5,#1              ;87
                  |L1.652|
00028c  42bd              CMP      r5,r7                 ;87
00028e  d3de              BCC      |L1.590|
                  |L1.656|
000290  bf00              NOP                            ;90
000292  4628              MOV      r0,r5                 ;94
000294  e7d7              B        |L1.582|
;;;96     
                          ENDP

                  _ZN4Uart10receiveLenEv PROC ; Uart::receiveLen()
;;;97     int Uart::receiveLen()
000296  b510              PUSH     {r4,lr}
;;;98     {	
000298  4604              MOV      r4,r0
;;;99     	return m_rq.receiveLen();
00029a  f1040008          ADD      r0,r4,#8
00029e  f7fffffe          BL       _ZN8ReceiveQIhE10receiveLenEv ; ReceiveQ<unsigned char>::receiveLen()
;;;100    }
0002a2  bd10              POP      {r4,pc}
;;;101    
                          ENDP

                  _ZN4Uart6updateEv PROC ; Uart::update()
;;;102    int Uart::update()
0002a4  4601              MOV      r1,r0
;;;103    {
;;;104    	if (m_flag==false)
0002a6  f8910034          LDRB     r0,[r1,#0x34]
0002aa  b920              CBNZ     r0,|L1.694|
;;;105    	{
;;;106    		m_uart->THR = 0; // send a 0 to get the transmit interrupt going again, send 16 bits		
0002ac  2000              MOVS     r0,#0
0002ae  684a              LDR      r2,[r1,#4]
0002b0  6010              STR      r0,[r2,#0]
;;;107    		m_uart->THR = 0; 		
0002b2  684a              LDR      r2,[r1,#4]
0002b4  6010              STR      r0,[r2,#0]
                  |L1.694|
;;;108    	}
;;;109    	return 0;
0002b6  2000              MOVS     r0,#0
;;;110    }
0002b8  4770              BX       lr
;;;111    
                          ENDP

                  _ZN4Uart11setBaudrateEj PROC ; Uart::setBaudrate(unsigned)
;;;145    
;;;146    int Uart::setBaudrate(uint32_t baudrate)
0002ba  b570              PUSH     {r4-r6,lr}
;;;147    {
0002bc  4604              MOV      r4,r0
0002be  460d              MOV      r5,r1
;;;148    	UART_setBaudRate(m_uart, baudrate, CLKFREQ);
0002c0  4a06              LDR      r2,|L1.732|
0002c2  4629              MOV      r1,r5
0002c4  6860              LDR      r0,[r4,#4]
0002c6  f7fffffe          BL       UART_setBaudRate
;;;149    	return 0;
0002ca  2000              MOVS     r0,#0
;;;150    }
0002cc  bd70              POP      {r4-r6,pc}
;;;151    
                          ENDP

0002ce  0000              DCW      0x0000
                  |L1.720|
                          DCD      g_uart0
                  |L1.724|
                          DCD      _ZTV7Iserial+0x8 ; vtable for Iserial
                  |L1.728|
                          DCD      _ZTV4Uart+0x8 ; vtable for Uart
                  |L1.732|
                          DCD      0x0c28cb00
                  |L1.736|
                          DCD      0xe000ed18
                  |L1.740|
                          DCD      0xe000e400
                  |L1.744|
                          DCD      0x40081000
                  |L1.748|
                          DCD      0xe000e180

                          AREA ||.ARM.exidx||, LINKORDER=||.text||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||.text||
                          DCD      0x00000001

                          AREA ||.data||, DATA, ALIGN=2

                  g_uart0
                          DCD      0x00000000

                          AREA ||.constdata__ZTV4Uart||, COMGROUP=_ZTV4Uart, DATA, READONLY, ALIGN=2

                  _ZTV4Uart ; vtable for Uart
                          DCD      0x00000000
                          DCD      _ZTI4Uart ; typeinfo for Uart
                          DCD      _ZN4Uart4openEv ; Uart::open()
                          DCD      _ZN4Uart5closeEv ; Uart::close()
                          DCD      _ZN4Uart7receiveEPhj ; Uart::receive(unsigned char*, unsigned)
                          DCD      _ZN4Uart10receiveLenEv ; Uart::receiveLen()
                          DCD      _ZN4Uart6updateEv ; Uart::update()

                          AREA ||t._ZN8ReceiveQIhE10receiveLenEv||, COMGROUP=_ZN8ReceiveQIhE10receiveLenEv, CODE, READONLY, ALIGN=1

                  _ZN8ReceiveQIhE10receiveLenEv PROC ; ReceiveQ<unsigned char>::receiveLen()
;;;41     
;;;42     	inline int32_t receiveLen()
000000  4601              MOV      r1,r0
;;;43     	{
;;;44     		return m_produced - m_consumed;
000002  e9d10204          LDRD     r0,r2,[r1,#0x10]
000006  1a80              SUBS     r0,r0,r2
;;;45     	}
000008  4770              BX       lr
;;;46     
                          ENDP


                          AREA ||area_number.21||, COMGROUP=_ZN8ReceiveQIhE10receiveLenEv, LINKORDER=||t._ZN8ReceiveQIhE10receiveLenEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.21||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN8ReceiveQIhE10receiveLenEv||
                          DCD      0x00000001

                          AREA ||.constdata__ZTV7Iserial||, COMGROUP=_ZTV7Iserial, DATA, READONLY, ALIGN=2

                  _ZTV7Iserial ; vtable for Iserial
                          DCD      0x00000000
                          DCD      _ZTI7Iserial ; typeinfo for Iserial
                          DCD      _ZN7Iserial4openEv ; Iserial::open()
                          DCD      _ZN7Iserial5closeEv ; Iserial::close()
                          DCD      _ZN7Iserial7receiveEPhj ; Iserial::receive(unsigned char*, unsigned)
                          DCD      _ZN7Iserial10receiveLenEv ; Iserial::receiveLen()
                          DCD      _ZN7Iserial6updateEv ; Iserial::update()

                          AREA ||.constdata__ZTI4Uart||, COMGROUP=_ZTI4Uart, DATA, READONLY, ALIGN=2

                  _ZTI4Uart ; typeinfo for Uart
                          DCD      _ZTVN10__cxxabiv120__si_class_type_infoE+0x8 ; vtable for __cxxabiv1::__si_class_type_info
                          DCD      _ZTS4Uart ; typeinfo name for Uart
                          DCD      _ZTI7Iserial ; typeinfo for Iserial

                          AREA ||.constdata__ZTI7Iserial||, COMGROUP=_ZTI7Iserial, DATA, READONLY, ALIGN=2

                  _ZTI7Iserial ; typeinfo for Iserial
                          DCD      _ZTVN10__cxxabiv117__class_type_infoE+0x8 ; vtable for __cxxabiv1::__class_type_info
                          DCD      _ZTS7Iserial ; typeinfo name for Iserial

                          AREA ||.constdata__ZTS4Uart||, COMGROUP=_ZTS4Uart, DATA, READONLY, ALIGN=0

                  _ZTS4Uart ; typeinfo name for Uart
000000  34556172          DCB      0x34,0x55,0x61,0x72
000004  7400              DCB      0x74,0x00

                          AREA ||.constdata__ZTS7Iserial||, COMGROUP=_ZTS7Iserial, DATA, READONLY, ALIGN=0

                  _ZTS7Iserial ; typeinfo name for Iserial
000000  37497365          DCB      0x37,0x49,0x73,0x65
000004  7269616c          DCB      0x72,0x69,0x61,0x6c
000008  00                DCB      0x00

                          AREA ||i._ZN7Iserial4openEv||, COMGROUP=_ZN7Iserial4openEv, CODE, READONLY, ALIGN=1

                  _ZN7Iserial4openEv PROC ; Iserial::open()
;;;131    public:
;;;132    	virtual int open()
000000  4601              MOV      r1,r0
;;;133    	{
;;;134    		return 0;
000002  2000              MOVS     r0,#0
;;;135    	}
000004  4770              BX       lr
;;;136    	virtual int close()
                          ENDP


                          AREA ||area_number.39||, COMGROUP=_ZN7Iserial4openEv, LINKORDER=||i._ZN7Iserial4openEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.39||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN7Iserial4openEv||
                          DCD      0x00000001

                          AREA ||i._ZN7Iserial5closeEv||, COMGROUP=_ZN7Iserial5closeEv, CODE, READONLY, ALIGN=1

                  _ZN7Iserial5closeEv PROC ; Iserial::close()
;;;135    	}
;;;136    	virtual int close()
000000  4601              MOV      r1,r0
;;;137    	{
;;;138    		return 0;
000002  2000              MOVS     r0,#0
;;;139    	}
000004  4770              BX       lr
;;;140    	virtual int receive(uint8_t *buf, uint32_t len)
                          ENDP


                          AREA ||area_number.46||, COMGROUP=_ZN7Iserial5closeEv, LINKORDER=||i._ZN7Iserial5closeEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.46||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN7Iserial5closeEv||
                          DCD      0x00000001

                          AREA ||i._ZN7Iserial7receiveEPhj||, COMGROUP=_ZN7Iserial7receiveEPhj, CODE, READONLY, ALIGN=1

                  _ZN7Iserial7receiveEPhj PROC ; Iserial::receive(unsigned char*, unsigned)
;;;139    	}
;;;140    	virtual int receive(uint8_t *buf, uint32_t len)
000000  4603              MOV      r3,r0
;;;141    	{
;;;142    		return 0;
000002  2000              MOVS     r0,#0
;;;143    	}
000004  4770              BX       lr
;;;144    	virtual int receiveLen()
                          ENDP


                          AREA ||area_number.53||, COMGROUP=_ZN7Iserial7receiveEPhj, LINKORDER=||i._ZN7Iserial7receiveEPhj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.53||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN7Iserial7receiveEPhj||
                          DCD      0x00000001

                          AREA ||i._ZN7Iserial10receiveLenEv||, COMGROUP=_ZN7Iserial10receiveLenEv, CODE, READONLY, ALIGN=1

                  _ZN7Iserial10receiveLenEv PROC ; Iserial::receiveLen()
;;;143    	}
;;;144    	virtual int receiveLen()
000000  4601              MOV      r1,r0
;;;145    	{
;;;146    		return 0;
000002  2000              MOVS     r0,#0
;;;147    	}
000004  4770              BX       lr
;;;148    	virtual int update()
                          ENDP


                          AREA ||area_number.60||, COMGROUP=_ZN7Iserial10receiveLenEv, LINKORDER=||i._ZN7Iserial10receiveLenEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.60||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN7Iserial10receiveLenEv||
                          DCD      0x00000001

                          AREA ||i._ZN7Iserial6updateEv||, COMGROUP=_ZN7Iserial6updateEv, CODE, READONLY, ALIGN=1

                  _ZN7Iserial6updateEv PROC ; Iserial::update()
;;;147    	}
;;;148    	virtual int update()
000000  4601              MOV      r1,r0
;;;149    	{
;;;150    		return 0;
000002  2000              MOVS     r0,#0
;;;151    	}
000004  4770              BX       lr
;;;152    };
                          ENDP


                          AREA ||area_number.67||, COMGROUP=_ZN7Iserial6updateEv, LINKORDER=||i._ZN7Iserial6updateEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.67||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN7Iserial6updateEv||
                          DCD      0x00000001

;*** Start embedded assembler ***

#line 1 "..\\libpixy\\uart.cpp"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___8_uart_cpp_bb43f66e___Z7__REV16j|
#line 130 "..\\libpixy\\core_cmInstr.h"
|__asm___8_uart_cpp_bb43f66e___Z7__REV16j| PROC
#line 131

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___8_uart_cpp_bb43f66e___Z7__REVSHi|
#line 144
|__asm___8_uart_cpp_bb43f66e___Z7__REVSHi| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
